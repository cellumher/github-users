"use strict"; (self.webpackChunkgithub_users = self.webpackChunkgithub_users || []).push([[179], { 443: () => { function re(e) { return "function" == typeof e } function Oo(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const Ro = Oo(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Nr(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class Mt { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (re(r)) try { r() } catch (i) { t = i instanceof Ro ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { wc(i) } catch (s) { t = t ?? [], s instanceof Ro ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new Ro(t) } } add(t) { var n; if (t && t !== this) if (this.closed) wc(t); else { if (t instanceof Mt) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Nr(n, t) } remove(t) { const { _finalizers: n } = this; n && Nr(n, t), t instanceof Mt && t._removeParent(this) } } Mt.EMPTY = (() => { const e = new Mt; return e.closed = !0, e })(); const vc = Mt.EMPTY; function Cc(e) { return e instanceof Mt || e && "closed" in e && re(e.remove) && re(e.add) && re(e.unsubscribe) } function wc(e) { re(e) ? e() : e.unsubscribe() } const _n = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, ko = { setTimeout(e, t, ...n) { const { delegate: r } = ko; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = ko; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Ec(e) { ko.setTimeout(() => { const { onUnhandledError: t } = _n; if (!t) throw e; t(e) }) } function bc() { } const k_ = As("C", void 0, void 0); function As(e, t, n) { return { kind: e, value: t, error: n } } let Dn = null; function Vo(e) { if (_n.useDeprecatedSynchronousErrorHandling) { const t = !Dn; if (t && (Dn = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Dn; if (Dn = null, n) throw r } } else e() } class Ts extends Mt { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Cc(t) && t.add(this)) : this.destination = U_ } static create(t, n, r) { return new xr(t, n, r) } next(t) { this.isStopped ? xs(function L_(e) { return As("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? xs(function V_(e) { return As("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? xs(k_, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const j_ = Function.prototype.bind; function Ns(e, t) { return j_.call(e, t) } class H_ { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { Lo(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { Lo(r) } else Lo(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { Lo(n) } } } class xr extends Ts { constructor(t, n, r) { let o; if (super(), re(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && _n.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && Ns(t.next, i), error: t.error && Ns(t.error, i), complete: t.complete && Ns(t.complete, i) }) : o = t } this.destination = new H_(o) } } function Lo(e) { _n.useDeprecatedSynchronousErrorHandling ? function B_(e) { _n.useDeprecatedSynchronousErrorHandling && Dn && (Dn.errorThrown = !0, Dn.error = e) }(e) : Ec(e) } function xs(e, t) { const { onStoppedNotification: n } = _n; n && ko.setTimeout(() => n(e, t)) } const U_ = { closed: !0, next: bc, error: function $_(e) { throw e }, complete: bc }, Fs = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Mc(e) { return e } let Me = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function z_(e) { return e && e instanceof Ts || function G_(e) { return e && re(e.next) && re(e.error) && re(e.complete) }(e) && Cc(e) }(n) ? n : new xr(n, r, o); return Vo(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Sc(r))((o, i) => { const s = new xr({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [Fs]() { return this } pipe(...n) { return function Ic(e) { return 0 === e.length ? Mc : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } }(n)(this) } toPromise(n) { return new (n = Sc(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Sc(e) { var t; return null !== (t = e ?? _n.Promise) && void 0 !== t ? t : Promise } const W_ = Oo(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Ps = (() => { class e extends Me { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Ac(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new W_ } next(n) { Vo(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { Vo(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { Vo(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? vc : (this.currentObservers = null, i.push(n), new Mt(() => { this.currentObservers = null, Nr(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new Me; return n.source = this, n } } return e.create = (t, n) => new Ac(t, n), e })(); class Ac extends Ps { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : vc } } function jn(e) { return t => { if (function q_(e) { return re(e?.lift) }(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Hn(e, t, n, r, o) { return new K_(e, t, n, r, o) } class K_ extends Ts { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function vn(e, t) { return jn((n, r) => { let o = 0; n.subscribe(Hn(r, i => { r.next(e.call(t, i, o++)) })) }) } function Cn(e) { return this instanceof Cn ? (this.v = e, this) : new Cn(e) } function J_(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function u(f) { f.value instanceof Cn ? Promise.resolve(f.value.v).then(l, c) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function l(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } } function Y_(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function xc(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function o(i, s, a, u) { Promise.resolve(u).then(function (l) { i({ value: l, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } const Fc = e => e && "number" == typeof e.length && "function" != typeof e; function Pc(e) { return re(e?.then) } function Oc(e) { return re(e[Fs]) } function Rc(e) { return Symbol.asyncIterator && re(e?.[Symbol.asyncIterator]) } function kc(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Vc = function eD() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Lc(e) { return re(e?.[Vc]) } function Bc(e) { return J_(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Cn(n.read()); if (o) return yield Cn(void 0); yield yield Cn(r) } } finally { n.releaseLock() } }) } function jc(e) { return re(e?.getReader) } function tn(e) { if (e instanceof Me) return e; if (null != e) { if (Oc(e)) return function tD(e) { return new Me(t => { const n = e[Fs](); if (re(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (Fc(e)) return function nD(e) { return new Me(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (Pc(e)) return function rD(e) { return new Me(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Ec) }) }(e); if (Rc(e)) return Hc(e); if (Lc(e)) return function oD(e) { return new Me(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (jc(e)) return function iD(e) { return Hc(Bc(e)) }(e) } throw kc(e) } function Hc(e) { return new Me(t => { (function sD(e, t) { var n, r, o, i; return function Z_(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(c) { try { l(r.next(c)) } catch (d) { s(d) } } function u(c) { try { l(r.throw(c)) } catch (d) { s(d) } } function l(c) { c.done ? i(c.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(c.value).then(a, u) } l((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = Y_(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function nn(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function Bo(e, t, n = 1 / 0) { return re(t) ? Bo((r, o) => vn((i, s) => t(r, i, o, s))(tn(e(r, o))), n) : ("number" == typeof t && (n = t), jn((r, o) => function aD(e, t, n, r, o, i, s, a) { const u = []; let l = 0, c = 0, d = !1; const f = () => { d && !u.length && !l && t.complete() }, h = g => l < r ? p(g) : u.push(g), p = g => { i && t.next(g), l++; let D = !1; tn(n(g, c++)).subscribe(Hn(t, _ => { o?.(_), i ? h(_) : t.next(_) }, () => { D = !0 }, void 0, () => { if (D) try { for (l--; u.length && l < r;) { const _ = u.shift(); s ? nn(t, s, () => p(_)) : p(_) } f() } catch (_) { t.error(_) } })) }; return e.subscribe(Hn(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } const $c = new Me(e => e.complete()); function Rs(e) { return e[e.length - 1] } function Uc(e) { return function cD(e) { return e && re(e.schedule) }(Rs(e)) ? e.pop() : void 0 } function Gc(e, t = 0) { return jn((n, r) => { n.subscribe(Hn(r, o => nn(r, e, () => r.next(o), t), () => nn(r, e, () => r.complete(), t), o => nn(r, e, () => r.error(o), t))) }) } function zc(e, t = 0) { return jn((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function Wc(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new Me(n => { nn(n, t, () => { const r = e[Symbol.asyncIterator](); nn(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function ks(e, t) { return t ? function _D(e, t) { if (null != e) { if (Oc(e)) return function hD(e, t) { return tn(e).pipe(zc(t), Gc(t)) }(e, t); if (Fc(e)) return function gD(e, t) { return new Me(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (Pc(e)) return function pD(e, t) { return tn(e).pipe(zc(t), Gc(t)) }(e, t); if (Rc(e)) return Wc(e, t); if (Lc(e)) return function mD(e, t) { return new Me(n => { let r; return nn(n, t, () => { r = e[Vc](), nn(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => re(r?.return) && r.return() }) }(e, t); if (jc(e)) return function yD(e, t) { return Wc(Bc(e), t) }(e, t) } throw kc(e) }(e, t) : tn(e) } function Vs(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new xr({ next: () => { r.unsubscribe(), e() } }); return t(...n).subscribe(r) } function J(e) { for (let t in e) if (e[t] === J) return t; throw Error("Could not find renamed property on target object.") } function Ls(e, t) { for (const n in t) t.hasOwnProperty(n) && !e.hasOwnProperty(n) && (e[n] = t[n]) } function Y(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(Y).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function Bs(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const CD = J({ __forward_ref__: J }); function X(e) { return e.__forward_ref__ = X, e.toString = function () { return Y(this()) }, e } function A(e) { return js(e) ? e() : e } function js(e) { return "function" == typeof e && e.hasOwnProperty(CD) && e.__forward_ref__ === X } class b extends Error { constructor(t, n) { super(function jo(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t.trim() : ""}` }(t, n)), this.code = t } } function F(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function Ho(e, t) { throw new b(-201, !1) } function Ze(e, t) { null == e && function q(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function G(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function ct(e) { return { providers: e.providers || [], imports: e.imports || [] } } function $o(e) { return qc(e, Uo) || qc(e, Zc) } function qc(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function Kc(e) { return e && (e.hasOwnProperty(Hs) || e.hasOwnProperty(TD)) ? e[Hs] : null } const Uo = J({ \u0275prov: J }), Hs = J({ \u0275inj: J }), Zc = J({ ngInjectableDef: J }), TD = J({ ngInjectorDef: J }); var T = (() => ((T = T || {})[T.Default = 0] = "Default", T[T.Host = 1] = "Host", T[T.Self = 2] = "Self", T[T.SkipSelf = 4] = "SkipSelf", T[T.Optional = 8] = "Optional", T))(); let $s; function rt(e) { const t = $s; return $s = e, t } function Qc(e, t, n) { const r = $o(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & T.Optional ? null : void 0 !== t ? t : void Ho(Y(e)) } function rn(e) { return { toString: e }.toString() } var dt = (() => ((dt = dt || {})[dt.OnPush = 0] = "OnPush", dt[dt.Default = 1] = "Default", dt))(), It = (() => { return (e = It || (It = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", It; var e })(); const ee = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), $n = {}, W = [], Go = J({ \u0275cmp: J }), Us = J({ \u0275dir: J }), Gs = J({ \u0275pipe: J }), Jc = J({ \u0275mod: J }), jt = J({ \u0275fac: J }), Fr = J({ __NG_ELEMENT_ID__: J }); let xD = 0; function on(e) { return rn(() => { const n = !0 === e.standalone, r = {}, o = { type: e.type, providersResolver: null, decls: e.decls, vars: e.vars, factory: null, template: e.template || null, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: r, inputs: null, outputs: null, exportAs: e.exportAs || null, onPush: e.changeDetection === dt.OnPush, directiveDefs: null, pipeDefs: null, standalone: n, dependencies: n && e.dependencies || null, getStandaloneInjector: null, selectors: e.selectors || W, viewQuery: e.viewQuery || null, features: e.features || null, data: e.data || {}, encapsulation: e.encapsulation || It.Emulated, id: "c" + xD++, styles: e.styles || W, _: null, setInput: null, schemas: e.schemas || null, tView: null }, i = e.dependencies, s = e.features; return o.inputs = ed(e.inputs, r), o.outputs = ed(e.outputs), s && s.forEach(a => a(o)), o.directiveDefs = i ? () => ("function" == typeof i ? i() : i).map(Yc).filter(Xc) : null, o.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(ke).filter(Xc) : null, o }) } function Yc(e) { return Z(e) || Re(e) } function Xc(e) { return null !== e } function St(e) { return rn(() => ({ type: e.type, bootstrap: e.bootstrap || W, declarations: e.declarations || W, imports: e.imports || W, exports: e.exports || W, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function ed(e, t) { if (null == e) return $n; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } const P = on; function Z(e) { return e[Go] || null } function Re(e) { return e[Us] || null } function ke(e) { return e[Gs] || null } const V = 11; function Ge(e) { return Array.isArray(e) && "object" == typeof e[1] } function ht(e) { return Array.isArray(e) && !0 === e[1] } function qs(e) { return 0 != (8 & e.flags) } function Ko(e) { return 2 == (2 & e.flags) } function Zo(e) { return 1 == (1 & e.flags) } function pt(e) { return null !== e.template } function VD(e) { return 0 != (256 & e[2]) } function In(e, t) { return e.hasOwnProperty(jt) ? e[jt] : null } class jD { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function At() { return rd } function rd(e) { return e.type.prototype.ngOnChanges && (e.setInput = $D), HD } function HD() { const e = id(this), t = e?.current; if (t) { const n = e.previous; if (n === $n) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function $D(e, t, n, r) { const o = id(e) || function UD(e, t) { return e[od] = t }(e, { previous: $n, current: null }), i = o.current || (o.current = {}), s = o.previous, a = this.declaredInputs[n], u = s[a]; i[a] = new jD(u && u.currentValue, t, s === $n), e[r] = t } At.ngInherit = !0; const od = "__ngSimpleChanges__"; function id(e) { return e[od] || null } function fe(e) { for (; Array.isArray(e);)e = e[0]; return e } function Qo(e, t) { return fe(t[e]) } function st(e, t) { return fe(t[e.index]) } function Ys(e, t) { return e.data[t] } function Ye(e, t) { const n = t[e]; return Ge(n) ? n : n[0] } function Jo(e) { return 64 == (64 & e[2]) } function sn(e, t) { return null == t ? null : e[t] } function sd(e) { e[18] = 0 } function Xs(e, t) { e[5] += t; let n = e, r = e[3]; for (; null !== r && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);)r[5] += t, n = r, r = r[3] } const N = { lFrame: md(null), bindingsEnabled: !0 }; function ud() { return N.bindingsEnabled } function y() { return N.lFrame.lView } function $() { return N.lFrame.tView } function Lr(e) { return N.lFrame.contextLView = e, e[8] } function Br(e) { return N.lFrame.contextLView = null, e } function ve() { let e = ld(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function ld() { return N.lFrame.currentTNode } function Tt(e, t) { const n = N.lFrame; n.currentTNode = e, n.isParent = t } function ea() { return N.lFrame.isParent } function ta() { N.lFrame.isParent = !1 } function qn() { return N.lFrame.bindingIndex++ } function ov(e, t) { const n = N.lFrame; n.bindingIndex = n.bindingRootIndex = e, na(t) } function na(e) { N.lFrame.currentDirectiveIndex = e } function oa(e) { N.lFrame.currentQueryIndex = e } function sv(e) { const t = e[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null } function pd(e, t, n) { if (n & T.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & T.Host || (o = sv(i), null === o || (i = i[15], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = N.lFrame = gd(); return r.currentTNode = t, r.lView = e, !0 } function ia(e) { const t = gd(), n = e[1]; N.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function gd() { const e = N.lFrame, t = null === e ? null : e.child; return null === t ? md(e) : t } function md(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function yd() { const e = N.lFrame; return N.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const _d = yd; function sa() { const e = yd(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function Le() { return N.lFrame.selectedIndex } function an(e) { N.lFrame.selectedIndex = e } function le() { const e = N.lFrame; return Ys(e.tView, e.selectedIndex) } function Yo(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: l, ngOnDestroy: c } = i; s && (e.contentHooks || (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks || (e.contentHooks = [])).push(n, a), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, a)), u && (e.viewHooks || (e.viewHooks = [])).push(-n, u), l && ((e.viewHooks || (e.viewHooks = [])).push(n, l), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, l)), null != c && (e.destroyHooks || (e.destroyHooks = [])).push(n, c) } } function Xo(e, t, n) { Dd(e, t, 3, n) } function ei(e, t, n, r) { (3 & e[2]) === n && Dd(e, t, n, r) } function aa(e, t) { let n = e[2]; (3 & n) === t && (n &= 2047, n += 1, e[2] = n) } function Dd(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[18] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[18] += 65536), (a < i || -1 == i) && (gv(e, n, t, u), e[18] = (4294901760 & e[18]) + u + 2), u++ } function gv(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; if (o) { if (e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t) { e[2] += 2048; try { i.call(a) } finally { } } } else try { i.call(a) } finally { } } class Hr { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function ti(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; Cd(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function vd(e) { return 3 === e || 4 === e || 6 === e } function Cd(e) { return 64 === e.charCodeAt(0) } function ni(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || wd(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function wd(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function Ed(e) { return -1 !== e } function Kn(e) { return 32767 & e } function Zn(e, t) { let n = function vv(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[15], n--; return r } let la = !0; function ri(e) { const t = la; return la = e, t } let Cv = 0; const Nt = {}; function Ur(e, t) { const n = da(e, t); if (-1 !== n) return n; const r = t[1]; r.firstCreatePass && (e.injectorIndex = t.length, ca(r.data, e), ca(t, null), ca(r.blueprint, null)); const o = oi(e, t), i = e.injectorIndex; if (Ed(o)) { const s = Kn(o), a = Zn(o, t), u = a[1].data; for (let l = 0; l < 8; l++)t[i + l] = a[s + l] | u[s + l] } return t[i + 8] = o, i } function ca(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function da(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function oi(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = Fd(o), null === r) return -1; if (n++, o = o[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function ii(e, t, n) { !function wv(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Fr) && (r = n[Fr]), null == r && (r = n[Fr] = Cv++); const o = 255 & r; t.data[e + (o >> 5)] |= 1 << o }(e, t, n) } function Id(e, t, n) { if (n & T.Optional || void 0 !== e) return e; Ho() } function Sd(e, t, n, r) { if (n & T.Optional && void 0 === r && (r = null), 0 == (n & (T.Self | T.Host))) { const o = e[9], i = rt(void 0); try { return o ? o.get(t, r, n & T.Optional) : Qc(t, r, n & T.Optional) } finally { rt(i) } } return Id(r, 0, n) } function Ad(e, t, n, r = T.Default, o) { if (null !== e) { if (1024 & t[2]) { const s = function Sv(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 1024 & s[2] && !(256 & s[2]);) { const a = Td(i, s, n, r | T.Self, Nt); if (a !== Nt) return a; let u = i.parent; if (!u) { const l = s[21]; if (l) { const c = l.get(n, Nt, r); if (c !== Nt) return c } u = Fd(s), s = s[15] } i = u } return o }(e, t, n, r, Nt); if (s !== Nt) return s } const i = Td(e, t, n, r, Nt); if (i !== Nt) return i } return Sd(t, n, r, o) } function Td(e, t, n, r, o) { const i = function Mv(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(Fr) ? e[Fr] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : Iv : t }(n); if ("function" == typeof i) { if (!pd(t, e, r)) return r & T.Host ? Id(o, 0, r) : Sd(t, n, r, o); try { const s = i(r); if (null != s || r & T.Optional) return s; Ho() } finally { _d() } } else if ("number" == typeof i) { let s = null, a = da(e, t), u = -1, l = r & T.Host ? t[16][6] : null; for ((-1 === a || r & T.SkipSelf) && (u = -1 === a ? oi(e, t) : t[a + 8], -1 !== u && xd(r, !1) ? (s = t[1], a = Kn(u), t = Zn(u, t)) : a = -1); -1 !== a;) { const c = t[1]; if (Nd(i, a, c.data)) { const d = bv(a, t, n, s, r, l); if (d !== Nt) return d } u = t[a + 8], -1 !== u && xd(r, t[1].data[a + 8] === l) && Nd(i, a, t) ? (s = c, a = Kn(u), t = Zn(u, t)) : a = -1 } } return o } function bv(e, t, n, r, o, i) { const s = t[1], a = s.data[e + 8], c = function si(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, c = i >> 20, f = o ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && pt(h) && h.type === n) return u } return null }(a, s, n, null == r ? Ko(a) && la : r != s && 0 != (3 & a.type), o & T.Host && i === a); return null !== c ? Gr(t, s, c, a) : Nt } function Gr(e, t, n, r) { let o = e[n]; const i = t.data; if (function mv(e) { return e instanceof Hr }(o)) { const s = o; s.resolving && function wD(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new b(-200, `Circular dependency in DI detected for ${e}${n}`) }(function z(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : F(e) }(i[n])); const a = ri(s.canSeeViewProviders); s.resolving = !0; const u = s.injectImpl ? rt(s.injectImpl) : null; pd(e, r, T.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function pv(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = rd(t); (n.preOrderHooks || (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, s) } o && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, o), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== u && rt(u), ri(a), s.resolving = !1, _d() } } return o } function Nd(e, t, n) { return !!(n[t + (e >> 5)] & 1 << e) } function xd(e, t) { return !(e & T.Self || e & T.Host && t) } class Qn { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return Ad(this._tNode, this._lView, t, r, n) } } function Iv() { return new Qn(ve(), y()) } function fa(e) { return js(e) ? () => { const t = fa(A(e)); return t && t() } : In(e) } function Fd(e) { const t = e[1], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[6] : null } const Yn = "__parameters__"; function er(e, t, n) { return rn(() => { const r = function pa(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(u, l, c) { const d = u.hasOwnProperty(Yn) ? u[Yn] : Object.defineProperty(u, Yn, { value: [] })[Yn]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), u } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class x { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = G({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function Ut(e, t) { e.forEach(n => Array.isArray(n) ? Ut(n, t) : t(n)) } function Od(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function ai(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function et(e, t, n) { let r = tr(e, t); return r >= 0 ? e[1 | r] = n : (r = ~r, function xv(e, t, n, r) { let o = e.length; if (o == t) e.push(n, r); else if (1 === o) e.push(r, e[0]), e[0] = n; else { for (o--, e.push(e[o - 1], e[o]); o > t;)e[o] = e[o - 2], o--; e[t] = n, e[t + 1] = r } }(e, r, t, n)), r } function ma(e, t) { const n = tr(e, t); if (n >= 0) return e[1 | n] } function tr(e, t) { return function Vd(e, t, n) { let r = 0, o = e.length >> n; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << n]; if (t === s) return i << n; s > t ? o = i : r = i + 1 } return ~(o << n) }(e, t, 1) } const Kr = {}, _a = "__NG_DI_FLAG__", li = "ngTempTokenPath", Bv = /\n/gm, Ld = "__source"; let Zr; function nr(e) { const t = Zr; return Zr = e, t } function Hv(e, t = T.Default) { if (void 0 === Zr) throw new b(-203, !1); return null === Zr ? Qc(e, void 0, t) : Zr.get(e, t & T.Optional ? null : void 0, t) } function L(e, t = T.Default) { return (function ND() { return $s }() || Hv)(A(e), t) } function Da(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = A(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new b(900, !1); let o, i = T.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = Uv(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(L(o, i)) } else t.push(L(r)) } return t } function Qr(e, t) { return e[_a] = t, e.prototype[_a] = t, e } function Uv(e) { return e[_a] } const ci = Qr(er("Optional"), 8), di = Qr(er("SkipSelf"), 4); let Ca; class Jd { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } function ln(e) { return e instanceof Jd ? e.changingThisBreaksApplicationSecurity : e } const hC = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi; var he = (() => ((he = he || {})[he.NONE = 0] = "NONE", he[he.HTML = 1] = "HTML", he[he.STYLE = 2] = "STYLE", he[he.SCRIPT = 3] = "SCRIPT", he[he.URL = 4] = "URL", he[he.RESOURCE_URL = 5] = "RESOURCE_URL", he))(); function yi(e) { const t = function to() { const e = y(); return e && e[12] }(); return t ? t.sanitize(he.URL, e) || "" : function Xr(e, t) { const n = function lC(e) { return e instanceof Jd && e.getTypeName() || null }(e); if (null != n && n !== t) { if ("ResourceURL" === n && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === t }(e, "URL") ? ln(e) : function ba(e) { return (e = String(e)).match(hC) ? e : "unsafe:" + e }(F(e)) } const sf = new x("ENVIRONMENT_INITIALIZER"), af = new x("INJECTOR", -1), uf = new x("INJECTOR_DEF_TYPES"); class lf { get(t, n = Kr) { if (n === Kr) { const r = new Error(`NullInjectorError: No provider for ${Y(t)}!`); throw r.name = "NullInjectorError", r } return n } } function SC(...e) { return { \u0275providers: cf(0, e) } } function cf(e, ...t) { const n = [], r = new Set; let o; return Ut(t, i => { const s = i; Aa(s, n, [], r) && (o || (o = []), o.push(s)) }), void 0 !== o && df(o, n), n } function df(e, t) { for (let n = 0; n < e.length; n++) { const { providers: o } = e[n]; Ut(o, i => { t.push(i) }) } } function Aa(e, t, n, r) { if (!(e = A(e))) return !1; let o = null, i = Kc(e); const s = !i && Z(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const u = e.ngModule; if (i = Kc(u), !i) return !1; o = u } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const u = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const l of u) Aa(l, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let l; r.add(o); try { Ut(i.imports, c => { Aa(c, t, n, r) && (l || (l = []), l.push(c)) }) } finally { } void 0 !== l && df(l, t) } if (!a) { const l = In(o) || (() => new o); t.push({ provide: o, useFactory: l, deps: W }, { provide: uf, useValue: o, multi: !0 }, { provide: sf, useValue: () => L(o), multi: !0 }) } const u = i.providers; null == u || a || Ut(u, c => { t.push(c) }) } } return o !== e && void 0 !== e.providers } const AC = J({ provide: String, useValue: J }); function Ta(e) { return null !== e && "object" == typeof e && AC in e } function Sn(e) { return "function" == typeof e } const Na = new x("Set Injector scope."), _i = {}, NC = {}; let xa; function Di() { return void 0 === xa && (xa = new lf), xa } class ir { } class pf extends ir { constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Pa(t, s => this.processProvider(s)), this.records.set(af, sr(void 0, this)), o.has("environment") && this.records.set(ir, sr(void 0, this)); const i = this.records.get(Na); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(uf.multi, W, T.Self)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); for (const t of this._onDestroyHooks) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(t) { this._onDestroyHooks.push(t) } runInContext(t) { this.assertNotDestroyed(); const n = nr(this), r = rt(void 0); try { return t() } finally { nr(n), rt(r) } } get(t, n = Kr, r = T.Default) { this.assertNotDestroyed(); const o = nr(this), i = rt(void 0); try { if (!(r & T.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const u = function RC(e) { return "function" == typeof e || "object" == typeof e && e instanceof x }(t) && $o(t); a = u && this.injectableDefInScope(u) ? sr(Fa(t), _i) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & T.Self ? Di() : this.parent).get(t, n = r & T.Optional && n === Kr ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[li] = s[li] || []).unshift(Y(t)), o) throw s; return function Gv(e, t, n, r) { const o = e[li]; throw t[Ld] && o.unshift(t[Ld]), e.message = function zv(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let o = Y(t); if (Array.isArray(t)) o = t.map(Y).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : Y(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(Bv, "\n  ")}` }("\n" + e.message, o, n, r), e.ngTokenPath = o, e[li] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { rt(i), nr(o) } } resolveInjectorInitializers() { const t = nr(this), n = rt(void 0); try { const r = this.get(sf.multi, W, T.Self); for (const o of r) o() } finally { nr(t), rt(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(Y(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new b(205, !1) } processProvider(t) { let n = Sn(t = A(t)) ? t : A(t && t.provide); const r = function FC(e) { return Ta(e) ? sr(void 0, e.useValue) : sr(gf(e), _i) }(t); if (Sn(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = sr(void 0, _i, !0), o.factory = () => Da(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === _i && (n.value = NC, n.value = n.factory()), "object" == typeof n.value && n.value && function OC(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = A(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function Fa(e) { const t = $o(e), n = null !== t ? t.factory : In(e); if (null !== n) return n; if (e instanceof x) throw new b(204, !1); if (e instanceof Function) return function xC(e) { const t = e.length; if (t > 0) throw function qr(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new b(204, !1); const n = function SD(e) { const t = e && (e[Uo] || e[Zc]); if (t) { const n = function AD(e) { if (e.hasOwnProperty("name")) return e.name; const t = ("" + e).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(e); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), t } return null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new b(204, !1) } function gf(e, t, n) { let r; if (Sn(e)) { const o = A(e); return In(o) || Fa(o) } if (Ta(e)) r = () => A(e.useValue); else if (function hf(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...Da(e.deps || [])); else if (function ff(e) { return !(!e || !e.useExisting) }(e)) r = () => L(A(e.useExisting)); else { const o = A(e && (e.useClass || e.provide)); if (!function PC(e) { return !!e.deps }(e)) return In(o) || Fa(o); r = () => new o(...Da(e.deps)) } return r } function sr(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function kC(e) { return !!e.\u0275providers } function Pa(e, t) { for (const n of e) Array.isArray(n) ? Pa(n, t) : kC(n) ? Pa(n.\u0275providers, t) : t(n) } class mf { } class BC { resolveComponentFactory(t) { throw function LC(e) { const t = Error(`No component factory found for ${Y(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(t) } } let vi = (() => { class e { } return e.NULL = new BC, e })(); function jC() { return ar(ve(), y()) } function ar(e, t) { return new gt(st(e, t)) } let gt = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = jC, e })(); class _f { } let An = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => function $C() { const e = y(), n = Ye(ve().index, e); return (Ge(n) ? n : e)[V] }(), e })(), UC = (() => { class e { } return e.\u0275prov = G({ token: e, providedIn: "root", factory: () => null }), e })(); class Ci { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const GC = new Ci("14.2.8"), Oa = {}; function Ba(e) { return e.ngOriginalError } class ur { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Ba(t); for (; n && Ba(n);)n = Ba(n); return n || null } } const ja = new Map; let nw = 0; const $a = "__ngContext__"; function Te(e, t) { Ge(t) ? (e[$a] = t[20], function ow(e) { ja.set(e[20], e) }(t)) : e[$a] = t } var ze = (() => ((ze = ze || {})[ze.Important = 1] = "Important", ze[ze.DashCase = 2] = "DashCase", ze))(); function Ga(e, t) { return undefined(e, t) } function ro(e) { const t = e[3]; return ht(t) ? t[3] : t } function za(e) { return Ff(e[13]) } function Wa(e) { return Ff(e[4]) } function Ff(e) { for (; null !== e && !ht(e);)e = e[4]; return e } function cr(e, t, n, r, o) { if (null != r) { let i, s = !1; ht(r) ? i = r : Ge(r) && (s = !0, r = r[0]); const a = fe(r); 0 === e && null !== n ? null == o ? Lf(t, n, a) : Tn(t, n, a, o || null, !0) : 1 === e && null !== n ? Tn(t, n, a, o || null, !0) : 2 === e ? function zf(e, t, n) { const r = wi(e, t); r && function xw(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function Ow(e, t, n, r, o) { const i = n[7]; i !== fe(n) && cr(t, e, r, i, o); for (let a = 10; a < n.length; a++) { const u = n[a]; oo(u[1], u, e, t, r, i) } }(t, e, i, n, o) } } function Ka(e, t, n) { return e.createElement(t, n) } function Of(e, t) { const n = e[9], r = n.indexOf(t), o = t[3]; 512 & t[2] && (t[2] &= -513, Xs(o, -1)), n.splice(r, 1) } function Za(e, t) { if (e.length <= 10) return; const n = 10 + t, r = e[n]; if (r) { const o = r[17]; null !== o && o !== e && Of(o, r), t > 0 && (e[n - 1][4] = r[4]); const i = ai(e, 10 + t); !function Ew(e, t) { oo(e, t, t[V], 2, null, null), t[0] = null, t[6] = null }(r[1], r); const s = i[19]; null !== s && s.detachView(i[1]), r[3] = null, r[4] = null, r[2] &= -65 } return r } function Rf(e, t) { if (!(128 & t[2])) { const n = t[V]; n.destroyNode && oo(e, t, n, 3, null, null), function Iw(e) { let t = e[13]; if (!t) return Qa(e[1], e); for (; t;) { let n = null; if (Ge(t)) n = t[13]; else { const r = t[10]; r && (n = r) } if (!n) { for (; t && !t[4] && t !== e;)Ge(t) && Qa(t[1], t), t = t[3]; null === t && (t = e), Ge(t) && Qa(t[1], t), n = t && t[4] } t = n } }(t) } } function Qa(e, t) { if (!(128 & t[2])) { t[2] &= -65, t[2] |= 128, function Nw(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof Hr)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; try { u.call(a) } finally { } } else try { i.call(o) } finally { } } } }(e, t), function Tw(e, t) { const n = e.cleanup, r = t[7]; let o = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 1], a = "function" == typeof s ? s(t) : fe(t[s]), u = r[o = n[i + 2]], l = n[i + 3]; "boolean" == typeof l ? a.removeEventListener(n[i], u, l) : l >= 0 ? r[o = l]() : r[o = -l].unsubscribe(), i += 2 } else { const s = r[o = n[i + 1]]; n[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)(0, r[i])(); t[7] = null } }(e, t), 1 === t[1].type && t[V].destroy(); const n = t[17]; if (null !== n && ht(t[3])) { n !== t[3] && Of(n, t); const r = t[19]; null !== r && r.detachView(e) } !function iw(e) { ja.delete(e[20]) }(t) } } function kf(e, t, n) { return function Vf(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const o = e.data[r.directiveStart].encapsulation; if (o === It.None || o === It.Emulated) return null } return st(r, n) }(e, t.parent, n) } function Tn(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Lf(e, t, n) { e.appendChild(t, n) } function Bf(e, t, n, r, o) { null !== r ? Tn(e, t, n, r, o) : Lf(e, t, n) } function wi(e, t) { return e.parentNode(t) } let $f = function Hf(e, t, n) { return 40 & e.type ? st(e, n) : null }; function Ei(e, t, n, r) { const o = kf(e, r, t), i = t[V], a = function jf(e, t, n) { return $f(e, t, n) }(r.parent || t[6], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)Bf(i, o, n[u], a, !1); else Bf(i, o, n, a, !1) } function bi(e, t) { if (null !== t) { const n = t.type; if (3 & n) return st(t, e); if (4 & n) return Ya(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return bi(e, r); { const o = e[t.index]; return ht(o) ? Ya(-1, o) : fe(o) } } if (32 & n) return Ga(t, e)() || fe(e[t.index]); { const r = Gf(e, t); return null !== r ? Array.isArray(r) ? r[0] : bi(ro(e[16]), r) : bi(e, t.next) } } return null } function Gf(e, t) { return null !== t ? e[16][6].projection[t.projection] : null } function Ya(e, t) { const n = 10 + e + 1; if (n < t.length) { const r = t[n], o = r[1].firstChild; if (null !== o) return bi(r, o) } return t[7] } function Xa(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && Te(fe(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & u) Xa(e, t, n.child, r, o, i, !1), cr(t, e, o, a, i); else if (32 & u) { const l = Ga(n, r); let c; for (; c = l();)cr(t, e, o, c, i); cr(t, e, o, a, i) } else 16 & u ? Wf(e, t, r, n, o, i) : cr(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function oo(e, t, n, r, o, i) { Xa(n, r, e.firstChild, t, o, i, !1) } function Wf(e, t, n, r, o, i) { const s = n[16], u = s[6].projection[r.projection]; if (Array.isArray(u)) for (let l = 0; l < u.length; l++)cr(t, e, o, u[l], i); else Xa(e, t, u, s[3], o, i, !0) } function qf(e, t, n) { e.setAttribute(t, "style", n) } function eu(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function Kf(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } const Zf = "ng-template"; function kw(e, t, n) { let r = 0; for (; r < e.length;) { let o = e[r++]; if (n && "class" === o) { if (o = e[r], -1 !== Kf(o.toLowerCase(), t, 0)) return !0 } else if (1 === o) { for (; r < e.length && "string" == typeof (o = e[r++]);)if (o.toLowerCase() === t) return !0; return !1 } } return !1 } function Qf(e) { return 4 === e.type && e.value !== Zf } function Vw(e, t, n) { return t === (4 !== e.type || n ? e.value : Zf) } function Lw(e, t, n) { let r = 4; const o = e.attrs || [], i = function Hw(e) { for (let t = 0; t < e.length; t++)if (vd(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !Vw(e, u, n) || "" === u && 1 === t.length) { if (mt(r)) return !1; s = !0 } } else { const l = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!kw(e.attrs, l, n)) { if (mt(r)) return !1; s = !0 } continue } const d = Bw(8 & r ? "class" : u, o, Qf(e), n); if (-1 === d) { if (mt(r)) return !1; s = !0; continue } if ("" !== l) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Kf(h, l, 0) || 2 & r && l !== f) { if (mt(r)) return !1; s = !0 } } } } else { if (!s && !mt(r) && !mt(u)) return !1; if (s && mt(u)) continue; s = !1, r = u | 1 & r } } return mt(r) || s } function mt(e) { return 0 == (1 & e) } function Bw(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function $w(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function Jf(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (Lw(e, t[r], n)) return !0; return !1 } function Yf(e, t) { return e ? ":not(" + t.trim() + ")" : t } function Gw(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !mt(s) && (t += Yf(i, o), o = ""), r = s, i = i || !mt(r); n++ } return "" !== o && (t += Yf(i, o)), t } const O = {}; function K(e) { Xf($(), y(), Le() + e, !1) } function Xf(e, t, n, r) { if (!r) if (3 == (3 & t[2])) { const i = e.preOrderCheckHooks; null !== i && Xo(t, i, n) } else { const i = e.preOrderHooks; null !== i && ei(t, i, 0, n) } an(n) } function rh(e, t = null, n = null, r) { const o = oh(e, t, n, r); return o.resolveInjectorInitializers(), o } function oh(e, t = null, n = null, r, o = new Set) { const i = [n || W, SC(e)]; return r = r || ("object" == typeof e ? void 0 : Y(e)), new pf(i, t || Di(), r || null, o) } let Wt = (() => { class e { static create(n, r) { if (Array.isArray(n)) return rh({ name: "" }, r, n, ""); { const o = n.name ?? ""; return rh({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = Kr, e.NULL = new lf, e.\u0275prov = G({ token: e, providedIn: "any", factory: () => L(af) }), e.__NG_ELEMENT_ID__ = -1, e })(); function v(e, t = T.Default) { const n = y(); return null === n ? L(e, t) : Ad(ve(), n, A(e), t) } function Ii(e, t) { return e << 17 | t << 2 } function yt(e) { return e >> 17 & 32767 } function iu(e) { return 2 | e } function qt(e) { return (131068 & e) >> 2 } function su(e, t) { return -131069 & e | t << 2 } function au(e) { return 1 | e } function Ch(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const o = n[r], i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; oa(o), s.contentQueries(2, t[i], i) } } } function Ti(e, t, n, r, o, i, s, a, u, l, c) { const d = t.blueprint.slice(); return d[0] = o, d[2] = 76 | r, (null !== c || e && 1024 & e[2]) && (d[2] |= 1024), sd(d), d[3] = d[15] = e, d[8] = n, d[10] = s || e && e[10], d[V] = a || e && e[V], d[12] = u || e && e[12] || null, d[9] = l || e && e[9] || null, d[6] = i, d[20] = function rw() { return nw++ }(), d[21] = c, d[16] = 2 == t.type ? e[16] : d, d } function fr(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function gu(e, t, n, r, o) { const i = ld(), s = ea(), u = e.data[t] = function SE(e, t, n, r, o, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u)), u }(e, t, n, r, o), function rv() { return N.lFrame.inI18n }() && (i.flags |= 64); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function jr() { const e = N.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return Tt(i, !0), i } function hr(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function mu(e, t, n) { ia(t); try { const r = e.viewQuery; null !== r && bu(1, r, n); const o = e.template; null !== o && wh(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Ch(e, t), e.staticViewQueries && bu(2, e.viewQuery, n); const i = e.components; null !== i && function bE(e, t) { for (let n = 0; n < t.length; n++)UE(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[2] &= -5, sa() } } function Ni(e, t, n, r) { const o = t[2]; if (128 != (128 & o)) { ia(t); try { sd(t), function dd(e) { return N.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && wh(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const l = e.preOrderCheckHooks; null !== l && Xo(t, l, null) } else { const l = e.preOrderHooks; null !== l && ei(t, l, 0, null), aa(t, 0) } if (function HE(e) { for (let t = za(e); null !== t; t = Wa(t)) { if (!t[2]) continue; const n = t[9]; for (let r = 0; r < n.length; r++) { const o = n[r], i = o[3]; 0 == (512 & o[2]) && Xs(i, 1), o[2] |= 512 } } }(t), function jE(e) { for (let t = za(e); null !== t; t = Wa(t))for (let n = 10; n < t.length; n++) { const r = t[n], o = r[1]; Jo(r) && Ni(o, r, o.template, r[8]) } }(t), null !== e.contentQueries && Ch(e, t), s) { const l = e.contentCheckHooks; null !== l && Xo(t, l) } else { const l = e.contentHooks; null !== l && ei(t, l, 1), aa(t, 1) } !function wE(e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const o = n[r]; if (o < 0) an(~o); else { const i = o, s = n[++r], a = n[++r]; ov(s, i), a(2, t[i]) } } } finally { an(-1) } }(e, t); const a = e.components; null !== a && function EE(e, t) { for (let n = 0; n < t.length; n++)$E(e, t[n]) }(t, a); const u = e.viewQuery; if (null !== u && bu(2, u, r), s) { const l = e.viewCheckHooks; null !== l && Xo(t, l) } else { const l = e.viewHooks; null !== l && ei(t, l, 2), aa(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[2] &= -41, 512 & t[2] && (t[2] &= -513, Xs(t[3], -1)) } finally { sa() } } } function wh(e, t, n, r, o) { const i = Le(), s = 2 & r; try { an(-1), s && t.length > 22 && Xf(e, t, 22, !1), n(r, o) } finally { an(i) } } function Eh(e, t, n) { if (qs(t)) { const o = t.directiveEnd; for (let i = t.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, n[i], i) } } } function yu(e, t, n) { !ud() || (function FE(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; e.firstCreatePass || Ur(n, t), Te(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], l = pt(u); l && VE(t, n, u); const c = Gr(t, e, a, n); Te(c, t), null !== s && LE(0, a - o, c, u, 0, s), l && (Ye(n.index, t)[8] = c) } }(e, t, n, st(n, t)), 128 == (128 & n.flags) && function PE(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function iv() { return N.lFrame.currentDirectiveIndex }(); try { an(i); for (let a = r; a < o; a++) { const u = e.data[a], l = t[a]; na(a), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && Nh(u, l) } } finally { an(-1), na(s) } }(e, t, n)) } function _u(e, t, n = st) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function bh(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = Du(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function Du(e, t, n, r, o, i, s, a, u, l) { const c = 22 + r, d = c + o, f = function ME(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : O); return n }(c, d), h = "function" == typeof l ? l() : l; return f[1] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: h, incompleteFirstPass: !1 } } function Ih(e, t, n) { for (let r in e) if (e.hasOwnProperty(r)) { const o = e[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(t, o) : n[r] = [t, o] } return n } function Sh(e, t) { const r = t.directiveEnd, o = e.data, i = t.attrs, s = []; let a = null, u = null; for (let l = t.directiveStart; l < r; l++) { const c = o[l], d = c.inputs, f = null === i || Qf(t) ? null : BE(d, i); s.push(f), a = Ih(d, l, a), u = Ih(c.outputs, l, u) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = s, t.inputs = a, t.outputs = u } function tt(e, t, n, r, o, i, s, a) { const u = st(t, n); let c, l = t.inputs; !a && null != l && (c = l[r]) ? (Mu(e, n, c, r, o), Ko(t) && Ah(n, t.index)) : 3 & t.type && (r = function AE(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(u, r, o)) } function Ah(e, t) { const n = Ye(t, e); 16 & n[2] || (n[2] |= 32) } function vu(e, t, n, r) { let o = !1; if (ud()) { const i = function OE(e, t, n) { const r = e.directiveRegistry; let o = null; if (r) for (let i = 0; i < r.length; i++) { const s = r[i]; Jf(n, s.selectors, !1) && (o || (o = []), ii(Ur(n, t), e, s.type), pt(s) ? (xh(e, n), o.unshift(s)) : o.push(s)) } return o }(e, t, n), s = null === r ? null : { "": -1 }; if (null !== i) { o = !0, Fh(n, e.data.length, i.length); for (let c = 0; c < i.length; c++) { const d = i[c]; d.providersResolver && d.providersResolver(d) } let a = !1, u = !1, l = hr(e, t, i.length, null); for (let c = 0; c < i.length; c++) { const d = i[c]; n.mergedAttrs = ni(n.mergedAttrs, d.hostAttrs), Ph(e, n, t, l, d), kE(l, d, s), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n.index), a = !0), !u && (f.ngOnChanges || f.ngDoCheck) && ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n.index), u = !0), l++ } Sh(e, n) } s && function RE(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new b(-301, !1); r.push(t[o], i) } } }(n, r, s) } return n.mergedAttrs = ni(n.mergedAttrs, n.attrs), o } function Th(e, t, n, r, o, i) { const s = i.hostBindings; if (s) { let a = e.hostBindingOpCodes; null === a && (a = e.hostBindingOpCodes = []); const u = ~t.index; (function xE(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != u && a.push(u), a.push(r, o, s) } } function Nh(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function xh(e, t) { t.flags |= 2, (e.components || (e.components = [])).push(t.index) } function kE(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; pt(t) && (n[""] = e) } } function Fh(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function Ph(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = In(o.type)), s = new Hr(i, pt(o), v); e.blueprint[r] = s, n[r] = s, Th(e, t, 0, r, hr(e, n, o.hostVars, O), o) } function VE(e, t, n) { const r = st(t, e), o = bh(n), i = e[10], s = xi(e, Ti(e, o, null, n.onPush ? 32 : 16, r, t, i, i.createRenderer(r, n), null, null, null)); e[t.index] = s } function LE(e, t, n, r, o, i) { const s = i[t]; if (null !== s) { const a = r.setInput; for (let u = 0; u < s.length;) { const l = s[u++], c = s[u++], d = s[u++]; null !== a ? r.setInput(n, d, l, c) : n[c] = d } } } function BE(e, t) { let n = null, r = 0; for (; r < t.length;) { const o = t[r]; if (0 !== o) if (5 !== o) { if ("number" == typeof o) break; e.hasOwnProperty(o) && (null === n && (n = []), n.push(o, e[o], t[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function Oh(e, t, n, r) { return new Array(e, !0, !1, t, null, 0, r, n, null, null) } function $E(e, t) { const n = Ye(t, e); if (Jo(n)) { const r = n[1]; 48 & n[2] ? Ni(r, n, r.template, n[8]) : n[5] > 0 && wu(n) } } function wu(e) { for (let r = za(e); null !== r; r = Wa(r))for (let o = 10; o < r.length; o++) { const i = r[o]; if (Jo(i)) if (512 & i[2]) { const s = i[1]; Ni(s, i, s.template, i[8]) } else i[5] > 0 && wu(i) } const n = e[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const o = Ye(n[r], e); Jo(o) && o[5] > 0 && wu(o) } } function UE(e, t) { const n = Ye(t, e), r = n[1]; (function GE(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), mu(r, n, n[8]) } function xi(e, t) { return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t } function Eu(e) { for (; e;) { e[2] |= 32; const t = ro(e); if (VD(e) && !t) return e; e = t } return null } function Fi(e, t, n, r = !0) { const o = t[10]; o.begin && o.begin(); try { Ni(e, t, e.template, n) } catch (s) { throw r && Lh(t, s), s } finally { o.end && o.end() } } function bu(e, t, n) { oa(0), t(e, n) } function Rh(e) { return e[7] || (e[7] = []) } function kh(e) { return e.cleanup || (e.cleanup = []) } function Lh(e, t) { const n = e[9], r = n ? n.get(ur, null) : null; r && r.handleError(t) } function Mu(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++], u = t[s], l = e.data[s]; null !== l.setInput ? l.setInput(u, o, r, a) : u[a] = o } } function Pi(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = Bs(o, a) : 2 == i && (r = Bs(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function Oi(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(fe(i)), ht(i)) for (let a = 10; a < i.length; a++) { const u = i[a], l = u[1].firstChild; null !== l && Oi(u[1], u, l, r) } const s = n.type; if (8 & s) Oi(e, t, n.child, r); else if (32 & s) { const a = Ga(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = Gf(t, n); if (Array.isArray(a)) r.push(...a); else { const u = ro(t[16]); Oi(u[1], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } class io { constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, n = t[1]; return Oi(n, t, n.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 128 == (128 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (ht(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (Za(t, r), ai(n, r)) } this._attachedToViewContainer = !1 } Rf(this._lView[1], this._lView) } onDestroy(t) { !function Mh(e, t, n, r) { const o = Rh(t); null === n ? o.push(r) : (o.push(n), e.firstCreatePass && kh(e).push(r, o.length - 1)) }(this._lView[1], this._lView, null, t) } markForCheck() { Eu(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -65 } reattach() { this._lView[2] |= 64 } detectChanges() { Fi(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new b(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function Mw(e, t) { oo(e, t, t[V], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new b(902, !1); this._appRef = t } } class zE extends io { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; Fi(t[1], t, t[8], !1) } checkNoChanges() { } get context() { return null } } class Iu extends vi { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = Z(t); return new so(n, this.ngModule) } } function Bh(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class qE { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { const o = this.injector.get(t, Oa, r); return o !== Oa || n === Oa ? o : this.parentInjector.get(t, n, r) } } class so extends mf { constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function zw(e) { return e.map(Gw).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return Bh(this.componentDef.inputs) } get outputs() { return Bh(this.componentDef.outputs) } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof ir ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new qE(t, i) : t, a = s.get(_f, null); if (null === a) throw new b(407, !1); const u = s.get(UC, null), l = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = r ? function IE(e, t, n) { return e.selectRootElement(t, n === It.ShadowDom) }(l, r, this.componentDef.encapsulation) : Ka(a.createRenderer(null, this.componentDef), c, function WE(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(c)), f = this.componentDef.onPush ? 288 : 272, h = Du(0, null, null, 1, 0, null, null, null, null, null), p = Ti(null, h, null, f, null, null, a, l, u, s, null); let g, D; ia(p); try { const _ = function QE(e, t, n, r, o, i) { const s = n[1]; n[22] = e; const u = fr(s, 22, 2, "#host", null), l = u.mergedAttrs = t.hostAttrs; null !== l && (Pi(u, l, !0), null !== e && (ti(o, e, l), null !== u.classes && eu(o, e, u.classes), null !== u.styles && qf(o, e, u.styles))); const c = r.createRenderer(e, t), d = Ti(n, bh(t), null, t.onPush ? 32 : 16, n[22], u, r, c, i || null, null, null); return s.firstCreatePass && (ii(Ur(u, n), s, t.type), xh(s, u), Fh(u, n.length, 1)), xi(n, d), n[22] = d }(d, this.componentDef, p, a, l); if (d) if (r) ti(l, d, ["ng-version", GC.full]); else { const { attrs: E, classes: m } = function Ww(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!mt(o)) break; o = i } r++ } return { attrs: t, classes: n } }(this.componentDef.selectors[0]); E && ti(l, d, E), m && m.length > 0 && eu(l, d, m.join(" ")) } if (D = Ys(h, 22), void 0 !== n) { const E = D.projection = []; for (let m = 0; m < this.ngContentSelectors.length; m++) { const M = n[m]; E.push(null != M ? Array.from(M) : null) } } g = function JE(e, t, n, r) { const o = n[1], i = function NE(e, t, n) { const r = ve(); e.firstCreatePass && (n.providersResolver && n.providersResolver(n), Ph(e, r, t, hr(e, t, 1, null), n), Sh(e, r)); const o = Gr(t, e, r.directiveStart, r); Te(o, t); const i = st(r, t); return i && Te(i, t), o }(o, n, t); if (e[8] = n[8] = i, null !== r) for (const a of r) a(i, t); if (t.contentQueries) { const a = ve(); t.contentQueries(1, i, a.directiveStart) } const s = ve(); return !o.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (an(s.index), Th(n[1], s, 0, s.directiveStart, s.directiveEnd, t), Nh(t, i)), i }(_, this.componentDef, p, [YE]), mu(h, p, null) } finally { sa() } return new ZE(this.componentType, g, ar(D, p), p, D) } } class ZE extends class VC { }{ constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = n, this.hostView = this.changeDetectorRef = new zE(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { const i = this._rootLView; Mu(i[1], i, o, t, n), Ah(i, this._tNode.index) } } get injector() { return new Qn(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function YE() { const e = ve(); Yo(y()[1], e) } function Q(e) { let t = function jh(e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), n = !0; const r = [e]; for (; t;) { let o; if (pt(e)) o = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new b(903, !1); o = t.\u0275dir } if (o) { if (n) { r.push(o); const s = e; s.inputs = Su(e.inputs), s.declaredInputs = Su(e.declaredInputs), s.outputs = Su(e.outputs); const a = o.hostBindings; a && nb(e, a); const u = o.viewQuery, l = o.contentQueries; if (u && eb(e, u), l && tb(e, l), Ls(e.inputs, o.inputs), Ls(e.declaredInputs, o.declaredInputs), Ls(e.outputs, o.outputs), pt(o) && o.data.animation) { const c = e.data; c.animation = (c.animation || []).concat(o.data.animation) } } const i = o.features; if (i) for (let s = 0; s < i.length; s++) { const a = i[s]; a && a.ngInherit && a(e), a === Q && (n = !1) } } t = Object.getPrototypeOf(t) } !function XE(e) { let t = 0, n = null; for (let r = e.length - 1; r >= 0; r--) { const o = e[r]; o.hostVars = t += o.hostVars, o.hostAttrs = ni(o.hostAttrs, n = ni(n, o.hostAttrs)) } }(r) } function Su(e) { return e === $n ? {} : e === W ? [] : e } function eb(e, t) { const n = e.viewQuery; e.viewQuery = n ? (r, o) => { t(r, o), n(r, o) } : t } function tb(e, t) { const n = e.contentQueries; e.contentQueries = n ? (r, o, i) => { t(r, o, i), n(r, o, i) } : t } function nb(e, t) { const n = e.hostBindings; e.hostBindings = n ? (r, o) => { t(r, o), n(r, o) } : t } let Ri = null; function Nn() { if (!Ri) { const e = ee.Symbol; if (e && e.iterator) Ri = e.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < t.length; ++n) { const r = t[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (Ri = r) } } } return Ri } function ao(e) { return !!function Au(e) { return null !== e && ("function" == typeof e || "object" == typeof e) }(e) && (Array.isArray(e) || !(e instanceof Map) && Nn() in e) } function Ne(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function gr(e, t, n, r) { return Ne(e, qn(), n) ? t + F(n) + r : O } function We(e, t, n, r, o, i, s, a) { const u = y(), l = $(), c = e + 22, d = l.firstCreatePass ? function cb(e, t, n, r, o, i, s, a, u) { const l = t.consts, c = fr(t, e, 4, s || null, sn(l, a)); vu(t, n, c, sn(l, u)), Yo(t, c); const d = c.tViews = Du(2, c, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, l); return null !== t.queries && (t.queries.template(t, c), d.queries = t.queries.embeddedTView(c)), c }(c, l, u, t, n, r, o, i, s) : l.data[c]; Tt(d, !1); const f = u[V].createComment(""); Ei(l, u, f, d), Te(f, u), xi(u, u[c] = Oh(f, u, f, d)), Zo(d) && yu(l, u, d), null != s && _u(u, d, a) } function _t(e) { return function Wn(e, t) { return e[t] }(function nv() { return N.lFrame.contextLView }(), 22 + e) } function pe(e, t, n) { const r = y(); return Ne(r, qn(), t) && tt($(), le(), r, e, t, r[V], n, !1), pe } function Tu(e, t, n, r, o) { const s = o ? "class" : "style"; Mu(e, n, t.inputs[s], s, r) } function j(e, t, n, r) { const o = y(), i = $(), s = 22 + e, a = o[V], u = o[s] = Ka(a, t, function hv() { return N.lFrame.currentNamespace }()), l = i.firstCreatePass ? function fb(e, t, n, r, o, i, s) { const a = t.consts, l = fr(t, e, 2, o, sn(a, i)); return vu(t, n, l, sn(a, s)), null !== l.attrs && Pi(l, l.attrs, !1), null !== l.mergedAttrs && Pi(l, l.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, l), l }(s, i, o, 0, t, n, r) : i.data[s]; Tt(l, !0); const c = l.mergedAttrs; null !== c && ti(a, u, c); const d = l.classes; null !== d && eu(a, u, d); const f = l.styles; return null !== f && qf(a, u, f), 64 != (64 & l.flags) && Ei(i, o, u, l), 0 === function JD() { return N.lFrame.elementDepthCount }() && Te(u, o), function YD() { N.lFrame.elementDepthCount++ }(), Zo(l) && (yu(i, o, l), Eh(i, l, o)), null !== r && _u(o, l), j } function H() { let e = ve(); ea() ? ta() : (e = e.parent, Tt(e, !1)); const t = e; !function XD() { N.lFrame.elementDepthCount-- }(); const n = $(); return n.firstCreatePass && (Yo(n, e), qs(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function _v(e) { return 0 != (16 & e.flags) }(t) && Tu(n, t, y(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function Dv(e) { return 0 != (32 & e.flags) }(t) && Tu(n, t, y(), t.stylesWithoutHost, !1), H } function Dt(e, t, n, r) { return j(e, t, n, r), H(), Dt } function Fn(e, t, n) { const r = y(), o = $(), i = e + 22, s = o.firstCreatePass ? function hb(e, t, n, r, o) { const i = t.consts, s = sn(i, r), a = fr(t, e, 8, "ng-container", s); return null !== s && Pi(a, s, !0), vu(t, n, a, sn(i, o)), null !== t.queries && t.queries.elementStart(t, a), a }(i, o, r, t, n) : o.data[i]; Tt(s, !0); const a = r[i] = r[V].createComment(""); return Ei(o, r, a, s), Te(a, r), Zo(s) && (yu(o, r, s), Eh(o, s, r)), null != n && _u(r, s), Fn } function Pn() { let e = ve(); const t = $(); return ea() ? ta() : (e = e.parent, Tt(e, !1)), t.firstCreatePass && (Yo(t, e), qs(e) && t.queries.elementEnd(e)), Pn } function Vi() { return y() } function Li(e) { return !!e && "function" == typeof e.then } const Yh = function Jh(e) { return !!e && "function" == typeof e.subscribe }; function ge(e, t, n, r) { const o = y(), i = $(), s = ve(); return function ep(e, t, n, r, o, i, s, a) { const u = Zo(r), c = e.firstCreatePass && kh(e), d = t[8], f = Rh(t); let h = !0; if (3 & r.type || a) { const D = st(r, t), _ = a ? a(D) : D, E = f.length, m = a ? U => a(fe(U[r.index])) : r.index; let M = null; if (!a && u && (M = function pb(e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[7], u = o[i + 2]; return a.length > u ? a[u] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== M) (M.__ngLastListenerFn__ || M).__ngNextListenerFn__ = i, M.__ngLastListenerFn__ = i, h = !1; else { i = np(r, t, d, i, !1); const U = n.listen(_, o, i); f.push(i, U), c && c.push(o, m, E, E + 1) } } else i = np(r, t, d, i, !1); const p = r.outputs; let g; if (h && null !== p && (g = p[o])) { const D = g.length; if (D) for (let _ = 0; _ < D; _ += 2) { const se = t[g[_]][g[_ + 1]].subscribe(i), Bn = f.length; f.push(i, se), c && c.push(o, r.index, Bn, -(Bn + 1)) } } }(i, o, o[V], s, e, t, 0, r), ge } function tp(e, t, n, r) { try { return !1 !== n(r) } catch (o) { return Lh(e, o), !1 } } function np(e, t, n, r, o) { return function i(s) { if (s === Function) return r; Eu(2 & e.flags ? Ye(e.index, t) : t); let u = tp(t, 0, r, s), l = i.__ngNextListenerFn__; for (; l;)u = tp(t, 0, l, s) && u, l = l.__ngNextListenerFn__; return o && !1 === u && (s.preventDefault(), s.returnValue = !1), u } } function nt(e = 1) { return function av(e) { return (N.lFrame.contextLView = function uv(e, t) { for (; e > 0;)t = t[15], e--; return t }(e, N.lFrame.contextLView))[8] }(e) } function lo(e, t, n) { return Nu(e, "", t, "", n), lo } function Nu(e, t, n, r, o) { const i = y(), s = gr(i, t, n, r); return s !== O && tt($(), le(), i, e, s, i[V], o, !1), Nu } function dp(e, t, n, r, o) { const i = e[n + 1], s = null === t; let a = r ? yt(i) : qt(i), u = !1; for (; 0 !== a && (!1 === u || s);) { const c = e[a + 1]; vb(e[a], t) && (u = !0, e[a + 1] = r ? au(c) : iu(c)), a = r ? yt(c) : qt(c) } u && (e[n + 1] = r ? iu(i) : au(i)) } function vb(e, t) { return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && tr(e, t) >= 0 } function Bi(e, t) { return function vt(e, t, n, r) { const o = y(), i = $(), s = function $t(e) { const t = N.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n }(2); i.firstUpdatePass && function vp(e, t, n, r) { const o = e.data; if (null === o[n + 1]) { const i = o[Le()], s = function Dp(e, t) { return t >= e.expandoStartIndex }(e, n); (function bp(e, t) { return 0 != (e.flags & (t ? 16 : 32)) })(i, r) && null === t && !s && (t = !1), t = function Tb(e, t, n, r) { const o = function ra(e) { const t = N.lFrame.currentDirectiveIndex; return -1 === t ? null : e[t] }(e); let i = r ? t.residualClasses : t.residualStyles; if (null === o) 0 === (r ? t.classBindings : t.styleBindings) && (n = co(n = xu(null, e, t, n, r), t.attrs, r), i = null); else { const s = t.directiveStylingLast; if (-1 === s || e[s] !== o) if (n = xu(o, e, t, n, r), null === i) { let u = function Nb(e, t, n) { const r = n ? t.classBindings : t.styleBindings; if (0 !== qt(r)) return e[yt(r)] }(e, t, r); void 0 !== u && Array.isArray(u) && (u = xu(null, e, t, u[1], r), u = co(u, t.attrs, r), function xb(e, t, n, r) { e[yt(n ? t.classBindings : t.styleBindings)] = r }(e, t, r, u)) } else i = function Fb(e, t, n) { let r; const o = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < o; i++)r = co(r, e[i].hostAttrs, n); return co(r, t.attrs, n) }(e, t, r) } return void 0 !== i && (r ? t.residualClasses = i : t.residualStyles = i), n }(o, i, t, r), function _b(e, t, n, r, o, i) { let s = i ? t.classBindings : t.styleBindings, a = yt(s), u = qt(s); e[r] = n; let c, l = !1; if (Array.isArray(n)) { const d = n; c = d[1], (null === c || tr(d, c) > 0) && (l = !0) } else c = n; if (o) if (0 !== u) { const f = yt(e[a + 1]); e[r + 1] = Ii(f, a), 0 !== f && (e[f + 1] = su(e[f + 1], r)), e[a + 1] = function fE(e, t) { return 131071 & e | t << 17 }(e[a + 1], r) } else e[r + 1] = Ii(a, 0), 0 !== a && (e[a + 1] = su(e[a + 1], r)), a = r; else e[r + 1] = Ii(u, 0), 0 === a ? a = r : e[u + 1] = su(e[u + 1], r), u = r; l && (e[r + 1] = iu(e[r + 1])), dp(e, c, r, !0), dp(e, c, r, !1), function Db(e, t, n, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof t && tr(i, t) >= 0 && (n[r + 1] = au(n[r + 1])) }(t, c, e, r, i), s = Ii(a, u), i ? t.classBindings = s : t.styleBindings = s }(o, i, t, n, s, r) } }(i, e, s, r), t !== O && Ne(o, s, t) && function wp(e, t, n, r, o, i, s, a) { if (!(3 & t.type)) return; const u = e.data, l = u[a + 1]; ji(function hh(e) { return 1 == (1 & e) }(l) ? Ep(u, t, n, o, qt(l), s) : void 0) || (ji(i) || function fh(e) { return 2 == (2 & e) }(l) && (i = Ep(u, null, n, o, a, s)), function Rw(e, t, n, r, o) { if (t) o ? e.addClass(n, r) : e.removeClass(n, r); else { let i = -1 === r.indexOf("-") ? void 0 : ze.DashCase; null == o ? e.removeStyle(n, r, i) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), i |= ze.Important), e.setStyle(n, r, o, i)) } }(r, s, Qo(Le(), n), o, i)) }(i, i.data[Le()], o, o[V], e, o[s + 1] = function Rb(e, t) { return null == e || ("string" == typeof t ? e += t : "object" == typeof e && (e = Y(ln(e)))), e }(t, n), r, s) }(e, t, null, !0), Bi } function xu(e, t, n, r, o) { let i = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (i = t[a], r = co(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (n.directiveStylingLast = a), r } function co(e, t, n) { const r = n ? 1 : 2; let o = -1; if (null !== t) for (let i = 0; i < t.length; i++) { const s = t[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), et(e, s, !!n || t[++i])) } return void 0 === e ? null : e } function Ep(e, t, n, r, o, i) { const s = null === t; let a; for (; o > 0;) { const u = e[o], l = Array.isArray(u), c = l ? u[1] : u, d = null === c; let f = n[o + 1]; f === O && (f = d ? W : void 0); let h = d ? ma(f, r) : c === r ? f : void 0; if (l && !ji(h) && (h = ma(u, r)), ji(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? yt(p) : qt(p) } if (null !== t) { let u = i ? t.residualClasses : t.residualStyles; null != u && (a = ma(u, r)) } return a } function ji(e) { return void 0 !== e } function me(e, t = "") { const n = y(), r = $(), o = e + 22, i = r.firstCreatePass ? fr(r, o, 1, t, null) : r.data[o], s = n[o] = function qa(e, t) { return e.createText(t) }(n[V], t); Ei(r, n, s, i), Tt(i, !1) } function Rt(e) { return fo("", e, ""), Rt } function fo(e, t, n) { const r = y(), o = gr(r, e, t, n); return o !== O && function Kt(e, t, n) { const r = Qo(t, e); !function Pf(e, t, n) { e.setValue(t, n) }(e[V], r, n) }(r, Le(), o), fo } const Mr = "en-US"; let Wp = Mr; function Ou(e, t, n, r, o) { if (e = A(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)Ou(e[i], t, n, r, o); else { const i = $(), s = y(); let a = Sn(e) ? e : A(e.provide), u = gf(e); const l = ve(), c = 1048575 & l.providerIndexes, d = l.directiveStart, f = l.providerIndexes >> 20; if (Sn(e) || !e.multi) { const h = new Hr(u, o, v), p = ku(a, t, o ? c : c + f, d); -1 === p ? (ii(Ur(l, s), i, a), Ru(i, e, t.length), t.push(a), l.directiveStart++, l.directiveEnd++, o && (l.providerIndexes += 1048576), n.push(h), s.push(h)) : (n[p] = h, s[p] = h) } else { const h = ku(a, t, c + f, d), p = ku(a, t, c, c + f), g = h >= 0 && n[h], D = p >= 0 && n[p]; if (o && !D || !o && !g) { ii(Ur(l, s), i, a); const _ = function XM(e, t, n, r, o) { const i = new Hr(e, n, v); return i.multi = [], i.index = t, i.componentProviders = 0, yg(i, o, r && !n), i }(o ? YM : JM, n.length, o, r, u); !o && D && (n[p].providerFactory = _), Ru(i, e, t.length, 0), t.push(a), l.directiveStart++, l.directiveEnd++, o && (l.providerIndexes += 1048576), n.push(_), s.push(_) } else Ru(i, e, h > -1 ? h : p, yg(n[o ? p : h], u, !o && r)); !o && r && D && n[p].componentProviders++ } } } function Ru(e, t, n, r) { const o = Sn(t), i = function TC(e) { return !!e.useClass }(t); if (o || i) { const u = (i ? A(t.useClass) : t).prototype.ngOnDestroy; if (u) { const l = e.destroyHooks || (e.destroyHooks = []); if (!o && t.multi) { const c = l.indexOf(n); -1 === c ? l.push(n, [r, u]) : l[c + 1].push(r, u) } else l.push(n, u) } } } function yg(e, t, n) { return n && e.componentProviders++, e.multi.push(t) - 1 } function ku(e, t, n, r) { for (let o = n; o < r; o++)if (t[o] === e) return o; return -1 } function JM(e, t, n, r) { return Vu(this.multi, []) } function YM(e, t, n, r) { const o = this.multi; let i; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Gr(n, n[1], this.providerFactory.index, r); i = a.slice(0, s), Vu(o, i); for (let u = s; u < a.length; u++)i.push(a[u]) } else i = [], Vu(o, i); return i } function Vu(e, t) { for (let n = 0; n < e.length; n++)t.push((0, e[n])()); return t } function ie(e, t = []) { return n => { n.providersResolver = (r, o) => function QM(e, t, n) { const r = $(); if (r.firstCreatePass) { const o = pt(e); Ou(n, r.data, r.blueprint, o, !0), Ou(t, r.data, r.blueprint, o, !1) } }(r, o ? o(e) : e, t) } } class Ir { } class _g extends Ir { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new Iu(this); const r = function Qe(e, t) { const n = e[Jc] || null; if (!n && !0 === t) throw new Error(`Type ${Y(e)} does not have '\u0275mod' property.`); return n }(t); this._bootstrapComponents = function zt(e) { return e instanceof Function ? e() : e }(r.bootstrap), this._r3Injector = oh(t, n, [{ provide: Ir, useValue: this }, { provide: vi, useValue: this.componentFactoryResolver }], Y(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Lu extends class e0 { }{ constructor(t) { super(), this.moduleType = t } create(t) { return new _g(this.moduleType, t) } } function ju(e) { return t => { setTimeout(e, void 0, t) } } const xe = class x0 extends Ps { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = ju(i), o && (o = ju(o)), s && (s = ju(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof Mt && t.add(a), a } }; let Qt = (() => { class e { } return e.__NG_ELEMENT_ID__ = R0, e })(); const P0 = Qt, O0 = class extends P0 { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(t, n) { const r = this._declarationTContainer.tViews, o = Ti(this._declarationLView, r, t, 16, null, r.declTNode, null, null, null, null, n || null); o[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (o[19] = s.createEmbeddedView(r)), mu(r, o, t), new io(o) } }; function R0() { return zi(ve(), y()) } function zi(e, t) { return 4 & e.type ? new O0(t, e, ar(e, t)) : null } let kt = (() => { class e { } return e.__NG_ELEMENT_ID__ = k0, e })(); function k0() { return function Pg(e, t) { let n; const r = t[e.index]; if (ht(r)) n = r; else { let o; if (8 & e.type) o = fe(r); else { const i = t[V]; o = i.createComment(""); const s = st(e, t); Tn(i, wi(i, s), o, function Fw(e, t) { return e.nextSibling(t) }(i, s), !1) } t[e.index] = n = Oh(r, t, o, e), xi(t, n) } return new xg(n, e, t) }(ve(), y()) } const V0 = kt, xg = class extends V0 { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return ar(this._hostTNode, this._hostLView) } get injector() { return new Qn(this._hostTNode, this._hostLView) } get parentInjector() { const t = oi(this._hostTNode, this._hostLView); if (Ed(t)) { const n = Zn(t, this._hostLView), r = Kn(t); return new Qn(n[1].data[r + 8], n) } return new Qn(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = Fg(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const s = t.createEmbeddedView(n || {}, i); return this.insert(s, o), s } createComponent(t, n, r, o, i) { const s = t && !function Wr(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.environmentInjector || d.ngModuleRef } const u = s ? t : new so(Z(t)), l = r || this.parentInjector; if (!i && null == u.ngModule) { const f = (s ? l : this.parentInjector).get(ir, null); f && (i = f) } const c = u.create(l, o, void 0, i); return this.insert(c.hostView, a), c } insert(t, n) { const r = t._lView, o = r[1]; if (function QD(e) { return ht(e[3]) }(r)) { const c = this.indexOf(t); if (-1 !== c) this.detach(c); else { const d = r[3], f = new xg(d, d[6], d[3]); f.detach(f.indexOf(t)) } } const i = this._adjustIndex(n), s = this._lContainer; !function Sw(e, t, n, r) { const o = 10 + r, i = n.length; r > 0 && (n[o - 1][4] = t), r < i - 10 ? (t[4] = n[o], Od(n, 10 + r, t)) : (n.push(t), t[4] = null), t[3] = n; const s = t[17]; null !== s && n !== s && function Aw(e, t) { const n = e[9]; t[16] !== t[3][3][16] && (e[2] = !0), null === n ? e[9] = [t] : n.push(t) }(s, t); const a = t[19]; null !== a && a.insertView(e), t[2] |= 64 }(o, r, s, i); const a = Ya(i, s), u = r[V], l = wi(u, s[7]); return null !== l && function bw(e, t, n, r, o, i) { r[0] = o, r[6] = t, oo(e, r, n, 1, o, i) }(o, s[6], u, r, l, a), t.attachToViewContainerRef(), Od($u(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = Fg(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = Za(this._lContainer, n); r && (ai($u(this._lContainer), n), Rf(r[1], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = Za(this._lContainer, n); return r && null != ai($u(this._lContainer), n) ? new io(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function Fg(e) { return e[8] } function $u(e) { return e[8] || (e[8] = []) } function Wi(e, t) { return zi(e, t) } function Ki(...e) { } const rm = new x("Application Initializer"); let Zi = (() => { class e { constructor(n) { this.appInits = n, this.resolve = Ki, this.reject = Ki, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (Li(i)) n.push(i); else if (Yh(i)) { const s = new Promise((a, u) => { i.subscribe({ complete: a, error: u }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)(L(rm, 8)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Co = new x("AppId", { providedIn: "root", factory: function om() { return `${Yu()}${Yu()}${Yu()}` } }); function Yu() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const im = new x("Platform Initializer"), Xu = new x("Platform ID", { providedIn: "platform", factory: () => "unknown" }), gI = new x("appBootstrapListener"), Jt = new x("LocaleId", { providedIn: "root", factory: () => function $v(e, t = T.Default) { return "number" != typeof t && (t = 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4)), L(e, t) }(Jt, T.Optional | T.SkipSelf) || function mI() { return typeof $localize < "u" && $localize.locale || Mr }() }), CI = (() => Promise.resolve(0))(); function el(e) { typeof Zone > "u" ? CI.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class Fe { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new xe(!1), this.onMicrotaskEmpty = new xe(!1), this.onStable = new xe(!1), this.onError = new xe(!1), typeof Zone > "u") throw new b(908, !1); Zone.assertZonePatched(); const o = this; if (o._nesting = 0, o._outer = o._inner = Zone.current, Zone.AsyncStackTaggingZoneSpec) { const i = Zone.AsyncStackTaggingZoneSpec; o._inner = o._inner.fork(new i("Angular")) } Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function wI() { let e = ee.requestAnimationFrame, t = ee.cancelAnimationFrame; if (typeof Zone < "u" && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function MI(e) { const t = () => { !function bI(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(ee, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, nl(e), e.isCheckStableRunning = !0, tl(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), nl(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return um(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), lm(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return um(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), lm(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, nl(e), tl(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Fe.isInAngularZone()) throw new b(909, !1) } static assertNotInAngularZone() { if (Fe.isInAngularZone()) throw new b(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, EI, Ki, Ki); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const EI = {}; function tl(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function nl(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function um(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function lm(e) { e._nesting--, tl(e) } class II { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new xe, this.onMicrotaskEmpty = new xe, this.onStable = new xe, this.onError = new xe } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const cm = new x(""), Qi = new x(""); let il, rl = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, il || (function SI(e) { il = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Fe.assertNotInAngularZone(), el(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) el(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(L(Fe), L(ol), L(Qi)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(), ol = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return il?.findTestabilityInTree(this, n, r) ?? null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(), fn = null; const dm = new x("AllowMultipleToken"), sl = new x("PlatformDestroyListeners"); function hm(e, t, n = []) { const r = `Platform: ${t}`, o = new x(r); return (i = []) => { let s = al(); if (!s || s.injector.get(dm, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function NI(e) { if (fn && !fn.get(dm, !1)) throw new b(400, !1); fn = e; const t = e.get(gm); (function fm(e) { const t = e.get(im, null); t && t.forEach(n => n()) })(e) }(function pm(e = [], t) { return Wt.create({ name: t, providers: [{ provide: Na, useValue: "platform" }, { provide: sl, useValue: new Set([() => fn = null]) }, ...e] }) }(a, r)) } return function FI(e) { const t = al(); if (!t) throw new b(401, !1); return t }() } } function al() { return fn?.get(gm) ?? null } let gm = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function ym(e, t) { let n; return n = "noop" === e ? new II : ("zone.js" === e ? void 0 : e) || new Fe(t), n }(r?.ngZone, function mm(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(r)), i = [{ provide: Fe, useValue: o }]; return o.run(() => { const s = Wt.create({ providers: i, parent: this.injector, name: n.moduleType.name }), a = n.create(s), u = a.injector.get(ur, null); if (!u) throw new b(402, !1); return o.runOutsideAngular(() => { const l = o.onError.subscribe({ next: c => { u.handleError(c) } }); a.onDestroy(() => { Ji(this._modules, a), l.unsubscribe() }) }), function _m(e, t, n) { try { const r = n(); return Li(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(u, o, () => { const l = a.injector.get(Zi); return l.runInitializers(), l.donePromise.then(() => (function qp(e) { Ze(e, "Expected localeId to be defined"), "string" == typeof e && (Wp = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(Jt, Mr) || Mr), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const o = Dm({}, r); return function AI(e, t, n) { const r = new Lu(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(ul); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new b(403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new b(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(sl, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(L(Wt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function Dm(e, t) { return Array.isArray(t) ? t.reduce(Dm, e) : { ...e, ...t } } let ul = (() => { class e { constructor(n, r, o) { this._zone = n, this._injector = r, this._exceptionHandler = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const i = new Me(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new Me(a => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { Fe.assertNotInAngularZone(), el(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const l = this._zone.onUnstable.subscribe(() => { Fe.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { u.unsubscribe(), l.unsubscribe() } }); this.isStable = function DD(...e) { const t = Uc(e), n = function fD(e, t) { return "number" == typeof Rs(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? tn(r[0]) : function uD(e = 1 / 0) { return Bo(Mc, e) }(n)(ks(r, t)) : $c }(i, s.pipe(function vD(e = {}) { const { connector: t = (() => new Ps), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, u, l = 0, c = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = u = void 0, c = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return jn((g, D) => { l++, !d && !c && f(); const _ = u = u ?? t(); D.add(() => { l--, 0 === l && !d && !c && (a = Vs(p, o)) }), _.subscribe(D), !s && l > 0 && (s = new xr({ next: E => _.next(E), error: E => { d = !0, f(), a = Vs(h, n, E), _.error(E) }, complete: () => { c = !0, f(), a = Vs(h, r), _.complete() } }), tn(g).subscribe(s)) })(i) } }())) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(n, r) { const o = n instanceof mf; if (!this._injector.get(Zi).done) throw !o && function Pr(e) { const t = Z(e) || Re(e) || ke(e); return null !== t && t.standalone }(n), new b(405, false); let s; s = o ? n : this._injector.get(vi).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function TI(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(Ir), l = s.create(Wt.NULL, [], r || s.selector, a), c = l.location.nativeElement, d = l.injector.get(cm, null); return d?.registerApplication(c), l.onDestroy(() => { this.detachView(l.hostView), Ji(this.components, l), d?.unregisterApplication(c) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new b(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; Ji(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(gI, []).concat(this._bootstrapListeners).forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => Ji(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new b(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (n) { return new (n || e)(L(Fe), L(ir), L(ur)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function Ji(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } let Cm = !0, bm = (() => { class e { } return e.__NG_ELEMENT_ID__ = RI, e })(); function RI(e) { return function kI(e, t, n) { if (Ko(e) && !n) { const r = Ye(e.index, t); return new io(r, r) } return 47 & e.type ? new io(t[16], t) : null }(ve(), y(), 16 == (16 & e)) } class Sm { constructor() { } supports(t) { return ao(t) } create(t) { return new $I(t) } } const HI = (e, t) => t; class $I { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || HI } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < Tm(r, o, i) ? n : r, a = Tm(s, o, i), u = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const l = a - o, c = u - o; if (l != c) { for (let f = 0; f < l; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; c <= p && p < l && (i[f] = h + 1) } i[s.previousIndex] = c - l } } a !== u && t(s, a, u) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !ao(t)) throw new b(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function ab(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Nn()](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new UI(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new Am), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Am), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class UI { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class GI { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class Am { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new GI, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Tm(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } function xm() { return new es([new Sm]) } let es = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || xm()), deps: [[e, new di, new ci]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new b(901, !1) } } return e.\u0275prov = G({ token: e, providedIn: "root", factory: xm }), e })(); const ZI = hm(null, "core", []); let QI = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(L(ul)) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({}), e })(); let ts = null; function kn() { return ts } const Vt = new x("DocumentToken"); function $m(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null } class jS { constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let El = (() => { class e { constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new jS(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), zm(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { zm(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(v(kt), v(Qt), v(es)) }, e.\u0275dir = P({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), e })(); function zm(e, t) { e.context.$implicit = t.item } let bl = (() => { class e { constructor(n, r) { this._viewContainer = n, this._context = new $S, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { Wm("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { Wm("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(v(kt), v(Qt)) }, e.\u0275dir = P({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), e })(); class $S { constructor() { this.$implicit = null, this.ngIf = null } } function Wm(e, t) { if (t && !t.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${Y(t)}'.`) } let gA = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({}), e })(); class Jm { } class xl extends class VA extends class XI { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function YI(e) { ts || (ts = e) }(new xl) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function LA() { return Io = Io || document.querySelector("base"), Io ? Io.getAttribute("href") : null }(); return null == n ? null : function BA(e) { fs = fs || document.createElement("a"), fs.setAttribute("href", e); const t = fs.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { Io = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return $m(document.cookie, t) } } let fs, Io = null; const ty = new x("TRANSITION_ID"), HA = [{ provide: rm, useFactory: function jA(e, t, n) { return () => { n.get(Zi).donePromise.then(() => { const r = kn(), o = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [ty, Vt, Wt], multi: !0 }]; let UA = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const hs = new x("EventManagerPlugins"); let ps = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => o.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } addGlobalEventListener(n, r, o) { return this._findPluginFor(r).addGlobalEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)(L(hs), L(Fe)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); class ny { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const o = kn().getGlobalEventTarget(this._doc, t); if (!o) throw new Error(`Unsupported event target ${o} for event ${n}`); return this.addEventListener(o, n, r) } } let ry = (() => { class e { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(o => { this._stylesSet.has(o) || (this._stylesSet.add(o), r.add(o)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(), So = (() => { class e extends ry { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, o) { n.forEach(i => { const s = this._doc.createElement("style"); s.textContent = i, o.push(r.appendChild(s)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(oy), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, o) => { this._addStylesToHost(n, o, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(oy)) } } return e.\u0275fac = function (n) { return new (n || e)(L(Vt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); function oy(e) { kn().remove(e) } const Fl = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Pl = /%COMP%/g; function gs(e, t, n) { for (let r = 0; r < t.length; r++) { let o = t[r]; Array.isArray(o) ? gs(e, o, n) : (o = o.replace(Pl, e), n.push(o)) } return n } function ay(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let Ol = (() => { class e { constructor(n, r, o) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.rendererByCompId = new Map, this.defaultRenderer = new Rl(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case It.Emulated: { let o = this.rendererByCompId.get(r.id); return o || (o = new ZA(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, o)), o.applyToHost(n), o } case 1: case It.ShadowDom: return new QA(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const o = gs(r.id, r.styles, []); this.sharedStylesHost.addStyles(o), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)(L(ps), L(So), L(Co)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); class Rl { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(Fl[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { (ly(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (ly(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = Fl[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = Fl[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (ze.DashCase | ze.Important) ? t.style.setProperty(n, r, o & ze.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & ze.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, ay(r)) : this.eventManager.addEventListener(t, n, ay(r)) } } function ly(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class ZA extends Rl { constructor(t, n, r, o) { super(t), this.component = r; const i = gs(o + "-" + r.id, r.styles, []); n.addStyles(i), this.contentAttr = function WA(e) { return "_ngcontent-%COMP%".replace(Pl, e) }(o + "-" + r.id), this.hostAttr = function qA(e) { return "_nghost-%COMP%".replace(Pl, e) }(o + "-" + r.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } class QA extends Rl { constructor(t, n, r, o) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = gs(o.id, o.styles, []); for (let s = 0; s < i.length; s++) { const a = document.createElement("style"); a.textContent = i[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let JA = (() => { class e extends ny { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)(L(Vt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const cy = ["alt", "control", "meta", "shift"], YA = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, XA = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let eT = (() => { class e extends ny { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => kn().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), cy.forEach(l => { const c = r.indexOf(l); c > -1 && (r.splice(c, 1), s += l + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const u = {}; return u.domEventName = o, u.fullKey = s, u } static matchEventFullKeyCode(n, r) { let o = YA[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), cy.forEach(s => { s !== o && (0, XA[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(L(Vt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const oT = hm(ZI, "browser", [{ provide: Xu, useValue: "browser" }, { provide: im, useValue: function tT() { xl.makeCurrent() }, multi: !0 }, { provide: Vt, useFactory: function rT() { return function tC(e) { Ca = e }(document), document }, deps: [] }]), hy = new x(""), py = [{ provide: Qi, useClass: class $A { addToWindow(t) { ee.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, ee.getAllAngularTestabilities = () => t.getAllTestabilities(), ee.getAllAngularRootElements = () => t.getAllRootElements(), ee.frameworkStabilizers || (ee.frameworkStabilizers = []), ee.frameworkStabilizers.push(r => { const o = ee.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (u) { s = s || u, i--, 0 == i && r(s) }; o.forEach(function (u) { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? kn().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: cm, useClass: rl, deps: [Fe, ol, Qi] }, { provide: rl, useClass: rl, deps: [Fe, ol, Qi] }], gy = [{ provide: Na, useValue: "root" }, { provide: ur, useFactory: function nT() { return new ur }, deps: [] }, { provide: hs, useClass: JA, multi: !0, deps: [Vt, Fe, Xu] }, { provide: hs, useClass: eT, multi: !0, deps: [Vt] }, { provide: Ol, useClass: Ol, deps: [ps, So, Co] }, { provide: _f, useExisting: Ol }, { provide: ry, useExisting: So }, { provide: So, useClass: So, deps: [Vt] }, { provide: ps, useClass: ps, deps: [hs, Fe] }, { provide: Jm, useClass: UA, deps: [] }, []]; let iT = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: Co, useValue: n.appId }, { provide: ty, useExisting: Co }, HA] } } } return e.\u0275fac = function (n) { return new (n || e)(L(hy, 12)) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({ providers: [...gy, ...py], imports: [gA, QI] }), e })(); typeof window < "u" && window; class _y { } class Dy { } class en { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(n => { const r = n.indexOf(":"); if (r > 0) { const o = n.slice(0, r), i = o.toLowerCase(), s = n.slice(r + 1).trim(); this.maybeSetNormalizedName(o, i), this.headers.has(i) ? this.headers.get(i).push(s) : this.headers.set(i, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(n => { let r = t[n]; const o = n.toLowerCase(); "string" == typeof r && (r = [r]), r.length > 0 && (this.headers.set(o, r), this.maybeSetNormalizedName(n, o)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const n = this.headers.get(t.toLowerCase()); return n && n.length > 0 ? n[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, n) { return this.clone({ name: t, value: n, op: "a" }) } set(t, n) { return this.clone({ name: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ name: t, value: n, op: "d" }) } maybeSetNormalizedName(t, n) { this.normalizedNames.has(n) || this.normalizedNames.set(n, t) } init() { this.lazyInit && (this.lazyInit instanceof en ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(n => { this.headers.set(n, t.headers.get(n)), this.normalizedNames.set(n, t.normalizedNames.get(n)) }) } clone(t) { const n = new en; return n.lazyInit = this.lazyInit && this.lazyInit instanceof en ? this.lazyInit : this, n.lazyUpdate = (this.lazyUpdate || []).concat([t]), n } applyUpdate(t) { const n = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let r = t.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(t.name, n); const o = ("a" === t.op ? this.headers.get(n) : void 0) || []; o.push(...r), this.headers.set(n, o); break; case "d": const i = t.value; if (i) { let s = this.headers.get(n); if (!s) return; s = s.filter(a => -1 === i.indexOf(a)), 0 === s.length ? (this.headers.delete(n), this.normalizedNames.delete(n)) : this.headers.set(n, s) } else this.headers.delete(n), this.normalizedNames.delete(n) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(n => t(this.normalizedNames.get(n), this.headers.get(n))) } } class _T { encodeKey(t) { return vy(t) } encodeValue(t) { return vy(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } const vT = /%(\d[a-f0-9])/gi, CT = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function vy(e) { return encodeURIComponent(e).replace(vT, (t, n) => CT[n] ?? t) } function ms(e) { return `${e}` } class pn { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new _T, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function DT(e, t) { const n = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(o => { const i = o.indexOf("="), [s, a] = -1 == i ? [t.decodeKey(o), ""] : [t.decodeKey(o.slice(0, i)), t.decodeValue(o.slice(i + 1))], u = n.get(s) || []; u.push(a), n.set(s, u) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(n => { const r = t.fromObject[n], o = Array.isArray(r) ? r.map(ms) : [ms(r)]; this.map.set(n, o) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const n = this.map.get(t); return n ? n[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, n) { return this.clone({ param: t, value: n, op: "a" }) } appendAll(t) { const n = []; return Object.keys(t).forEach(r => { const o = t[r]; Array.isArray(o) ? o.forEach(i => { n.push({ param: r, value: i, op: "a" }) }) : n.push({ param: r, value: o, op: "a" }) }), this.clone(n) } set(t, n) { return this.clone({ param: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ param: t, value: n, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const n = this.encoder.encodeKey(t); return this.map.get(t).map(r => n + "=" + this.encoder.encodeValue(r)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const n = new pn({ encoder: this.encoder }); return n.cloneFrom = this.cloneFrom || this, n.updates = (this.updates || []).concat(t), n } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const n = ("a" === t.op ? this.map.get(t.param) : void 0) || []; n.push(ms(t.value)), this.map.set(t.param, n); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let r = this.map.get(t.param) || []; const o = r.indexOf(ms(t.value)); -1 !== o && r.splice(o, 1), r.length > 0 ? this.map.set(t.param, r) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class wT { constructor() { this.map = new Map } set(t, n) { return this.map.set(t, n), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } has(t) { return this.map.has(t) } keys() { return this.map.keys() } } function Cy(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function wy(e) { return typeof Blob < "u" && e instanceof Blob } function Ey(e) { return typeof FormData < "u" && e instanceof FormData } class Ao { constructor(t, n, r, o) { let i; if (this.url = n, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function ET(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || o ? (this.body = void 0 !== r ? r : null, i = o) : i = r, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params)), this.headers || (this.headers = new en), this.context || (this.context = new wT), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = n; else { const a = n.indexOf("?"); this.urlWithParams = n + (-1 === a ? "?" : a < n.length - 1 ? "&" : "") + s } } else this.params = new pn, this.urlWithParams = n } serializeBody() { return null === this.body ? null : Cy(this.body) || wy(this.body) || Ey(this.body) || function bT(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof pn ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || Ey(this.body) ? null : wy(this.body) ? this.body.type || null : Cy(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof pn ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { const n = t.method || this.method, r = t.url || this.url, o = t.responseType || this.responseType, i = void 0 !== t.body ? t.body : this.body, s = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let u = t.headers || this.headers, l = t.params || this.params; const c = t.context ?? this.context; return void 0 !== t.setHeaders && (u = Object.keys(t.setHeaders).reduce((d, f) => d.set(f, t.setHeaders[f]), u)), t.setParams && (l = Object.keys(t.setParams).reduce((d, f) => d.set(f, t.setParams[f]), l)), new Ao(n, r, i, { params: l, headers: u, context: c, reportProgress: a, responseType: o, withCredentials: s }) } } var De = (() => ((De = De || {})[De.Sent = 0] = "Sent", De[De.UploadProgress = 1] = "UploadProgress", De[De.ResponseHeader = 2] = "ResponseHeader", De[De.DownloadProgress = 3] = "DownloadProgress", De[De.Response = 4] = "Response", De[De.User = 5] = "User", De))(); class Ll { constructor(t, n = 200, r = "OK") { this.headers = t.headers || new en, this.status = void 0 !== t.status ? t.status : n, this.statusText = t.statusText || r, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Bl extends Ll { constructor(t = {}) { super(t), this.type = De.ResponseHeader } clone(t = {}) { return new Bl({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class ys extends Ll { constructor(t = {}) { super(t), this.type = De.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new ys({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class by extends Ll { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function jl(e, t) { return { body: t, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let My = (() => { class e { constructor(n) { this.handler = n } request(n, r, o = {}) { let i; if (n instanceof Ao) i = n; else { let u, l; u = o.headers instanceof en ? o.headers : new en(o.headers), o.params && (l = o.params instanceof pn ? o.params : new pn({ fromObject: o.params })), i = new Ao(n, r, void 0 !== o.body ? o.body : null, { headers: u, context: o.context, params: l, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials }) } const s = function gT(...e) { return ks(e, Uc(e)) }(i).pipe(function mT(e, t) { return re(t) ? Bo(e, t, 1) : Bo(e, 1) }(u => this.handler.handle(u))); if (n instanceof Ao || "events" === o.observe) return s; const a = s.pipe(function yT(e, t) { return jn((n, r) => { let o = 0; n.subscribe(Hn(r, i => e.call(t, i, o++) && r.next(i))) }) }(u => u instanceof ys)); switch (o.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return a.pipe(vn(u => { if (null !== u.body && !(u.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return u.body })); case "blob": return a.pipe(vn(u => { if (null !== u.body && !(u.body instanceof Blob)) throw new Error("Response is not a Blob."); return u.body })); case "text": return a.pipe(vn(u => { if (null !== u.body && "string" != typeof u.body) throw new Error("Response is not a string."); return u.body })); default: return a.pipe(vn(u => u.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${o.observe}}`) } } delete(n, r = {}) { return this.request("DELETE", n, r) } get(n, r = {}) { return this.request("GET", n, r) } head(n, r = {}) { return this.request("HEAD", n, r) } jsonp(n, r) { return this.request("JSONP", n, { params: (new pn).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(n, r = {}) { return this.request("OPTIONS", n, r) } patch(n, r, o = {}) { return this.request("PATCH", n, jl(o, r)) } post(n, r, o = {}) { return this.request("POST", n, jl(o, r)) } put(n, r, o = {}) { return this.request("PUT", n, jl(o, r)) } } return e.\u0275fac = function (n) { return new (n || e)(L(_y)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); class Iy { constructor(t, n) { this.next = t, this.interceptor = n } handle(t) { return this.interceptor.intercept(t, this.next) } } const Sy = new x("HTTP_INTERCEPTORS"); let MT = (() => { class e { intercept(n, r) { return r.handle(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const IT = /^\)\]\}',?\n/; let Ay = (() => { class e { constructor(n) { this.xhrFactory = n } handle(n) { if ("JSONP" === n.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new Me(r => { const o = this.xhrFactory.build(); if (o.open(n.method, n.urlWithParams), n.withCredentials && (o.withCredentials = !0), n.headers.forEach((h, p) => o.setRequestHeader(h, p.join(","))), n.headers.has("Accept") || o.setRequestHeader("Accept", "application/json, text/plain, */*"), !n.headers.has("Content-Type")) { const h = n.detectContentTypeHeader(); null !== h && o.setRequestHeader("Content-Type", h) } if (n.responseType) { const h = n.responseType.toLowerCase(); o.responseType = "json" !== h ? h : "text" } const i = n.serializeBody(); let s = null; const a = () => { if (null !== s) return s; const h = o.statusText || "OK", p = new en(o.getAllResponseHeaders()), g = function ST(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(o) || n.url; return s = new Bl({ headers: p, status: o.status, statusText: h, url: g }), s }, u = () => { let { headers: h, status: p, statusText: g, url: D } = a(), _ = null; 204 !== p && (_ = typeof o.response > "u" ? o.responseText : o.response), 0 === p && (p = _ ? 200 : 0); let E = p >= 200 && p < 300; if ("json" === n.responseType && "string" == typeof _) { const m = _; _ = _.replace(IT, ""); try { _ = "" !== _ ? JSON.parse(_) : null } catch (M) { _ = m, E && (E = !1, _ = { error: M, text: _ }) } } E ? (r.next(new ys({ body: _, headers: h, status: p, statusText: g, url: D || void 0 })), r.complete()) : r.error(new by({ error: _, headers: h, status: p, statusText: g, url: D || void 0 })) }, l = h => { const { url: p } = a(), g = new by({ error: h, status: o.status || 0, statusText: o.statusText || "Unknown Error", url: p || void 0 }); r.error(g) }; let c = !1; const d = h => { c || (r.next(a()), c = !0); let p = { type: De.DownloadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), "text" === n.responseType && !!o.responseText && (p.partialText = o.responseText), r.next(p) }, f = h => { let p = { type: De.UploadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), r.next(p) }; return o.addEventListener("load", u), o.addEventListener("error", l), o.addEventListener("timeout", l), o.addEventListener("abort", l), n.reportProgress && (o.addEventListener("progress", d), null !== i && o.upload && o.upload.addEventListener("progress", f)), o.send(i), r.next({ type: De.Sent }), () => { o.removeEventListener("error", l), o.removeEventListener("abort", l), o.removeEventListener("load", u), o.removeEventListener("timeout", l), n.reportProgress && (o.removeEventListener("progress", d), null !== i && o.upload && o.upload.removeEventListener("progress", f)), o.readyState !== o.DONE && o.abort() } }) } } return e.\u0275fac = function (n) { return new (n || e)(L(Jm)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const Hl = new x("XSRF_COOKIE_NAME"), $l = new x("XSRF_HEADER_NAME"); class Ty { } let AT = (() => { class e { constructor(n, r, o) { this.doc = n, this.platform = r, this.cookieName = o, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const n = this.doc.cookie || ""; return n !== this.lastCookieString && (this.parseCount++, this.lastToken = $m(n, this.cookieName), this.lastCookieString = n), this.lastToken } } return e.\u0275fac = function (n) { return new (n || e)(L(Vt), L(Xu), L(Hl)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(), Ul = (() => { class e { constructor(n, r) { this.tokenService = n, this.headerName = r } intercept(n, r) { const o = n.url.toLowerCase(); if ("GET" === n.method || "HEAD" === n.method || o.startsWith("http://") || o.startsWith("https://")) return r.handle(n); const i = this.tokenService.getToken(); return null !== i && !n.headers.has(this.headerName) && (n = n.clone({ headers: n.headers.set(this.headerName, i) })), r.handle(n) } } return e.\u0275fac = function (n) { return new (n || e)(L(Ty), L($l)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(), TT = (() => { class e { constructor(n, r) { this.backend = n, this.injector = r, this.chain = null } handle(n) { if (null === this.chain) { const r = this.injector.get(Sy, []); this.chain = r.reduceRight((o, i) => new Iy(o, i), this.backend) } return this.chain.handle(n) } } return e.\u0275fac = function (n) { return new (n || e)(L(Dy), L(Wt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(), NT = (() => { class e { static disable() { return { ngModule: e, providers: [{ provide: Ul, useClass: MT }] } } static withOptions(n = {}) { return { ngModule: e, providers: [n.cookieName ? { provide: Hl, useValue: n.cookieName } : [], n.headerName ? { provide: $l, useValue: n.headerName } : []] } } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({ providers: [Ul, { provide: Sy, useExisting: Ul, multi: !0 }, { provide: Ty, useClass: AT }, { provide: Hl, useValue: "XSRF-TOKEN" }, { provide: $l, useValue: "X-XSRF-TOKEN" }] }), e })(), xT = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({ providers: [My, { provide: _y, useClass: TT }, Ay, { provide: Dy, useExisting: Ay }], imports: [NT.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })] }), e })(); const { isArray: FT } = Array, { getPrototypeOf: PT, prototype: OT, keys: RT } = Object; const { isArray: LT } = Array; function HT(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) } function $T(...e) { const t = function dD(e) { return re(Rs(e)) ? e.pop() : void 0 }(e), { args: n, keys: r } = function kT(e) { if (1 === e.length) { const t = e[0]; if (FT(t)) return { args: t, keys: null }; if (function VT(e) { return e && "object" == typeof e && PT(e) === OT }(t)) { const n = RT(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e), o = new Me(i => { const { length: s } = n; if (!s) return void i.complete(); const a = new Array(s); let u = s, l = s; for (let c = 0; c < s; c++) { let d = !1; tn(n[c]).subscribe(Hn(i, f => { d || (d = !0, l--), a[c] = f }, () => u--, void 0, () => { (!u || !d) && (l || i.next(r ? HT(r, a) : a), i.complete()) })) } }); return t ? o.pipe(function jT(e) { return vn(t => function BT(e, t) { return LT(t) ? e(...t) : e(t) }(e, t)) }(t)) : o } let Ny = (() => { class e { constructor(n, r) { this._renderer = n, this._elementRef = r, this.onChange = o => { }, this.onTouched = () => { } } setProperty(n, r) { this._renderer.setProperty(this._elementRef.nativeElement, n, r) } registerOnTouched(n) { this.onTouched = n } registerOnChange(n) { this.onChange = n } setDisabledState(n) { this.setProperty("disabled", n) } } return e.\u0275fac = function (n) { return new (n || e)(v(An), v(gt)) }, e.\u0275dir = P({ type: e }), e })(), Vn = (() => { class e extends Ny { } return e.\u0275fac = function () { let t; return function (r) { return (t || (t = function Ae(e) { return rn(() => { const t = e.prototype.constructor, n = t[jt] || fa(t), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[jt] || fa(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) }(e)))(r || e) } }(), e.\u0275dir = P({ type: e, features: [Q] }), e })(); const Lt = new x("NgValueAccessor"), GT = { provide: Lt, useExisting: X(() => To), multi: !0 }, WT = new x("CompositionEventMode"); let To = (() => { class e extends Ny { constructor(n, r, o) { super(n, r), this._compositionMode = o, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function zT() { const e = kn() ? kn().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(n) { this.setProperty("value", n ?? "") } _handleInput(n) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(n) } _compositionStart() { this._composing = !0 } _compositionEnd(n) { this._composing = !1, this._compositionMode && this.onChange(n) } } return e.\u0275fac = function (n) { return new (n || e)(v(An), v(gt), v(WT, 8)) }, e.\u0275dir = P({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (n, r) { 1 & n && ge("input", function (i) { return r._handleInput(i.target.value) })("blur", function () { return r.onTouched() })("compositionstart", function () { return r._compositionStart() })("compositionend", function (i) { return r._compositionEnd(i.target.value) }) }, features: [ie([GT]), Q] }), e })(); const Oe = new x("NgValidators"), mn = new x("NgAsyncValidators"); function Hy(e) { return null != e } function $y(e) { return Li(e) ? ks(e) : e } function Uy(e) { let t = {}; return e.forEach(n => { t = null != n ? { ...t, ...n } : t }), 0 === Object.keys(t).length ? null : t } function Gy(e, t) { return t.map(n => n(e)) } function zy(e) { return e.map(t => function ZT(e) { return !e.validate }(t) ? t : n => t.validate(n)) } function Gl(e) { return null != e ? function Wy(e) { if (!e) return null; const t = e.filter(Hy); return 0 == t.length ? null : function (n) { return Uy(Gy(n, t)) } }(zy(e)) : null } function zl(e) { return null != e ? function qy(e) { if (!e) return null; const t = e.filter(Hy); return 0 == t.length ? null : function (n) { return $T(Gy(n, t).map($y)).pipe(vn(Uy)) } }(zy(e)) : null } function Ky(e, t) { return null === e ? [t] : Array.isArray(e) ? [...e, t] : [e, t] } function Wl(e) { return e ? Array.isArray(e) ? e : [e] : [] } function Ds(e, t) { return Array.isArray(e) ? e.includes(t) : e === t } function Jy(e, t) { const n = Wl(t); return Wl(e).forEach(o => { Ds(n, o) || n.push(o) }), n } function Yy(e, t) { return Wl(t).filter(n => !Ds(e, n)) } class Xy { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = Gl(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = zl(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, n) { return !!this.control && this.control.hasError(t, n) } getError(t, n) { return this.control ? this.control.getError(t, n) : null } } class $e extends Xy { get formDirective() { return null } get path() { return null } } class yn extends Xy { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } let ql = (() => { class e extends class e_ { constructor(t) { this._cd = t } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } }{ constructor(n) { super(n) } } return e.\u0275fac = function (n) { return new (n || e)(v(yn, 2)) }, e.\u0275dir = P({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (n, r) { 2 & n && Bi("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending) }, features: [Q] }), e })(); const No = "VALID", Cs = "INVALID", Tr = "PENDING", xo = "DISABLED"; function n_(e) { return Array.isArray(e) ? Gl(e) : e || null } function r_(e) { return Array.isArray(e) ? zl(e) : e || null } function ws(e) { return null != e && !Array.isArray(e) && "object" == typeof e } function Fo(e, t) { (function ec(e, t) { const n = function Zy(e) { return e._rawValidators }(e); null !== t.validator ? e.setValidators(Ky(n, t.validator)) : "function" == typeof n && e.setValidators([n]); const r = function Qy(e) { return e._rawAsyncValidators }(e); null !== t.asyncValidator ? e.setAsyncValidators(Ky(r, t.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const o = () => e.updateValueAndValidity(); Ms(t._rawValidators, o), Ms(t._rawAsyncValidators, o) })(e, t), t.valueAccessor.writeValue(e.value), e.disabled && t.valueAccessor.setDisabledState?.(!0), function iN(e, t) { t.valueAccessor.registerOnChange(n => { e._pendingValue = n, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && a_(e, t) }) }(e, t), function aN(e, t) { const n = (r, o) => { t.valueAccessor.writeValue(r), o && t.viewToModelUpdate(r) }; e.registerOnChange(n), t._registerOnDestroy(() => { e._unregisterOnChange(n) }) }(e, t), function sN(e, t) { t.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && a_(e, t), "submit" !== e.updateOn && e.markAsTouched() }) }(e, t), function oN(e, t) { if (t.valueAccessor.setDisabledState) { const n = r => { t.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(n), t._registerOnDestroy(() => { e._unregisterOnDisabledChange(n) }) } }(e, t) } function Ms(e, t) { e.forEach(n => { n.registerOnValidatorChange && n.registerOnValidatorChange(t) }) } function a_(e, t) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } function d_(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } function f_(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } const gN = { provide: yn, useExisting: X(() => Ss) }, m_ = (() => Promise.resolve())(); let Ss = (() => { class e extends yn { constructor(n, r, o, i, s) { super(), this._changeDetectorRef = s, this.control = new class extends class s_ { constructor(t, n) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = n, this._composedValidatorFn = n_(this._rawValidators), this._composedAsyncValidatorFn = r_(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === No } get invalid() { return this.status === Cs } get pending() { return this.status == Tr } get disabled() { return this.status === xo } get enabled() { return this.status !== xo } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = n_(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = r_(t) } addValidators(t) { this.setValidators(Jy(t, this._rawValidators)) } addAsyncValidators(t) { this.setAsyncValidators(Jy(t, this._rawAsyncValidators)) } removeValidators(t) { this.setValidators(Yy(t, this._rawValidators)) } removeAsyncValidators(t) { this.setAsyncValidators(Yy(t, this._rawAsyncValidators)) } hasValidator(t) { return Ds(this._rawValidators, t) } hasAsyncValidator(t) { return Ds(this._rawAsyncValidators, t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(n => { n.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(n => { n.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = Tr, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = xo, this.errors = null, this._forEachChild(r => { r.disable({ ...t, onlySelf: !0 }) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...t, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!0)) } enable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = No, this._forEachChild(r => { r.enable({ ...t, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors({ ...t, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } getRawValue() { return this.value } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === No || this.status === Tr) && this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(n => n._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? xo : No } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = Tr, this._hasOwnPendingAsyncValidator = !0; const n = $y(this.asyncValidator(this)); this._asyncValidationSubscription = n.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, n = {}) { this.errors = t, this._updateControlsErrors(!1 !== n.emitEvent) } get(t) { let n = t; return null == n || (Array.isArray(n) || (n = n.split(".")), 0 === n.length) ? null : n.reduce((r, o) => r && r._find(o), this) } getError(t, n) { const r = n ? this.get(n) : this; return r && r.errors ? r.errors[t] : null } hasError(t, n) { return !!this.getError(t, n) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new xe, this.statusChanges = new xe } _calculateStatus() { return this._allControlsDisabled() ? xo : this.errors ? Cs : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Tr) ? Tr : this._anyControlsHaveStatus(Cs) ? Cs : No } _anyControlsHaveStatus(t) { return this._anyControls(n => n.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { ws(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(t) { return null } }{ constructor(t = null, n, r) { super(function Jl(e) { return (ws(e) ? e.validators : e) || null }(n), function Yl(e, t) { return (ws(t) ? t.asyncValidators : e) || null }(r, n)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(t), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), ws(n) && (n.nonNullable || n.initialValueIsDefault) && (this.defaultValue = f_(t) ? t.value : t) } setValue(t, n = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== n.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== n.emitViewToModelChange)), this.updateValueAndValidity(n) } patchValue(t, n = {}) { this.setValue(t, n) } reset(t = this.defaultValue, n = {}) { this._applyFormState(t), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { d_(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { d_(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { f_(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } }, this._registered = !1, this.update = new xe, this._parent = n, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = function nc(e, t) { if (!t) return null; let n, r, o; return Array.isArray(t), t.forEach(i => { i.constructor === To ? n = i : function cN(e) { return Object.getPrototypeOf(e.constructor) === Vn }(i) ? r = i : o = i }), o || r || n || null }(0, i) } ngOnChanges(n) { if (this._checkForErrors(), !this._registered || "name" in n) { if (this._registered && (this._checkName(), this.formDirective)) { const r = n.name.previousValue; this.formDirective.removeControl({ name: r, path: this._getPath(r) }) } this._setUpControl() } "isDisabled" in n && this._updateDisabled(n), function tc(e, t) { if (!e.hasOwnProperty("model")) return !1; const n = e.model; return !!n.isFirstChange() || !Object.is(t, n.currentValue) }(n, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { Fo(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(n) { m_.then(() => { this.control.setValue(n, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(n) { const r = n.isDisabled.currentValue, o = 0 !== r && function hl(e) { return "boolean" == typeof e ? e : null != e && "false" !== e }(r); m_.then(() => { o && !this.control.disabled ? this.control.disable() : !o && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(n) { return this._parent ? function Es(e, t) { return [...t.path, e] }(n, this._parent) : [n] } } return e.\u0275fac = function (n) { return new (n || e)(v($e, 9), v(Oe, 10), v(mn, 10), v(Lt, 10), v(bm, 8)) }, e.\u0275dir = P({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [ie([gN]), Q, At] }), e })(); const _N = { provide: Lt, useExisting: X(() => oc), multi: !0 }; let __ = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({}), e })(), DN = (() => { class e { constructor() { this._accessors = [] } add(n, r) { this._accessors.push([n, r]) } remove(n) { for (let r = this._accessors.length - 1; r >= 0; --r)if (this._accessors[r][1] === n) return void this._accessors.splice(r, 1) } select(n) { this._accessors.forEach(r => { this._isSameGroup(r, n) && r[1] !== n && r[1].fireUncheck(n.value) }) } _isSameGroup(n, r) { return !!n[0].control && n[0]._parent === r._control._parent && n[1].name === r.name } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: __ }), e })(), oc = (() => { class e extends Vn { constructor(n, r, o, i) { super(n, r), this._registry = o, this._injector = i, this.onChange = () => { } } ngOnInit() { this._control = this._injector.get(yn), this._checkName(), this._registry.add(this._control, this) } ngOnDestroy() { this._registry.remove(this) } writeValue(n) { this._state = n === this.value, this.setProperty("checked", this._state) } registerOnChange(n) { this._fn = n, this.onChange = () => { n(this.value), this._registry.select(this) } } fireUncheck(n) { this.writeValue(n) } _checkName() { !this.name && this.formControlName && (this.name = this.formControlName) } } return e.\u0275fac = function (n) { return new (n || e)(v(An), v(gt), v(DN), v(Wt)) }, e.\u0275dir = P({ type: e, selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]], hostBindings: function (n, r) { 1 & n && ge("change", function () { return r.onChange() })("blur", function () { return r.onTouched() }) }, inputs: { name: "name", formControlName: "formControlName", value: "value" }, features: [ie([_N]), Q] }), e })(), jN = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({ imports: [__] }), e })(), HN = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = St({ type: e }), e.\u0275inj = ct({ imports: [jN] }), e })(), UN = (() => { class e { constructor(n) { this.http = n, this.baseURL = "https://api.github.com/" } getUser(n) { return this.http.get(this.baseURL + "users/" + n) } getRepos(n, r) { return this.http.get(this.baseURL + "users/" + n + "/repos?page=" + r) } getLanguages(n) { return this.http.get(this.baseURL + "repos/" + n + "/languages") } } return e.\u0275fac = function (n) { return new (n || e)(L(My)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), GN = (() => { class e { constructor(n) { this.service = n, this.username = "octokit", this.repos = [], this.reposRemaining = !0, this.currentPage = 1, this.allLanguages = new Set, this.loadingUser = !1, this.loadingRepos = !1 } ngOnInit() { this.searchInfo() } searchInfo() { !this.username || this.username.toLocaleLowerCase() === this.user?.login.toLocaleLowerCase() || (this.loadingUser = !0, this.loadingRepos = !0, this.repos = [], this.allLanguages = new Set, this.searchUser()) } searchUser() { this.service.getUser(this.username).subscribe(n => { this.user = n, this.found = !0, this.errorUser = null, this.username = "", this.reposRemaining = !0, this.currentPage = 1, this.loadingUser = !1, this.searchRepos() }, n => { this.found = !1, this.errorUser = n, this.reposRemaining = !1, this.currentPage = 1, this.loadingUser = !1 }) } searchRepos() { this.loadingRepos = !0, this.service.getRepos(this.user?.login, this.currentPage).subscribe(n => { n.length < 30 && (this.reposRemaining = !1), n.map(r => { this.service.getLanguages(r.full_name).subscribe(o => (r.languages = o, r.languages_array = Object.keys(o), r.languages_array.map(i => this.allLanguages.add(i)), r), o => this.errorRepo = o) }), this.loadingRepos = !1, this.repos = [...this.repos, ...n], this.errorRepo = null, this.currentPage++ }, n => { this.errorRepo = n, this.reposRemaining = !1, this.loadingRepos = !1 }) } alternarTema() { document.body.classList.toggle("dark-theme") } } return e.\u0275fac = function (n) { return new (n || e)(v(UN)) }, e.\u0275cmp = on({ type: e, selectors: [["app-navbar"]], decls: 9, vars: 1, consts: [[1, "nav-elements"], [1, "tema", 3, "click"], [1, "toggle-theme"], ["src", "assets/toggle-theme.svg", 2, "opacity", "0"], [1, "user-search"], ["type", "text", "placeholder", "Buscar usuario de Github", 3, "ngModel", "ngModelChange", "keyup.enter"], [3, "click"]], template: function (n, r) { 1 & n && (j(0, "nav")(1, "div", 0)(2, "button", 1), ge("click", function () { return r.alternarTema() }), j(3, "div", 2), Dt(4, "img", 3), H()(), j(5, "div", 4)(6, "input", 5), ge("ngModelChange", function (i) { return r.username = i })("keyup.enter", function () { return r.searchInfo() }), H(), j(7, "button", 6), ge("click", function () { return r.searchInfo() }), me(8, "Buscar"), H()()()()), 2 & n && (K(6), pe("ngModel", r.username)) }, dependencies: [To, ql, Ss], styles: [".nav-elements[_ngcontent-%COMP%]{width:100%;max-width:1200px;display:flex;justify-content:space-between;padding:0 20px}.user-search[_ngcontent-%COMP%]{width:80%;display:flex;justify-content:flex-end}.tema[_ngcontent-%COMP%]{border-radius:50%}.toggle-theme[_ngcontent-%COMP%]{background-color:var(--btn-text-color);mask:url(assets/toggle-theme.svg) no-repeat center;-webkit-mask:url(assets/toggle-theme.svg) no-repeat center}"] }), e })(), R_ = (() => { class e { constructor() { } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = on({ type: e, selectors: [["app-not-found"]], inputs: { error: "error" }, decls: 4, vars: 2, template: function (n, r) { 1 & n && (j(0, "h2"), me(1), H(), j(2, "p"), me(3), H()), 2 & n && (K(1), Rt(null == r.error ? null : r.error.status), K(2), Rt(null == r.error ? null : r.error.error.message)) } }), e })(); function zN(e, t) { if (1 & e && (j(0, "span"), me(1), H()), 2 & e) { const n = t.$implicit; K(1), fo("", n, " ") } } function WN(e, t) { if (1 & e && (j(0, "tr")(1, "td"), me(2), H(), j(3, "td"), me(4), H(), j(5, "td", 10)(6, "p", 11)(7, "a", 12), me(8), H()()(), j(9, "td", 13), me(10), H(), j(11, "td"), We(12, zN, 2, 1, "span", 9), H()()), 2 & e) { const n = t.$implicit; K(2), Rt(n.name), K(2), Rt(n.description), K(3), lo("href", n.html_url, yi), K(1), Rt(n.html_url), K(2), Rt(n.stargazers_count), K(2), pe("ngForOf", n.languages_array) } } function qN(e, t) { if (1 & e && (Fn(0), We(1, WN, 13, 6, "tr", 9), Pn()), 2 & e) { const n = nt(); K(1), pe("ngForOf", n.reposShown) } } function KN(e, t) { if (1 & e && (j(0, "td", 14), Dt(1, "app-not-found", 15), H()), 2 & e) { const n = nt(); K(1), pe("error", n.error) } } let ZN = (() => { class e { constructor() { this.reposEmpty = !1, this.sortingParameters = { name: { asc: !0 }, stars: { asc: !1 }, lastSort: { column: "name", asc: !1 } } } ngOnInit() { } ngOnChanges(n) { this.repeatLastSort(), this.filterRepos() } filterRepos() { this.reposShown = this.filter && "" !== this.filter ? this.repos.filter(n => n.name.toLocaleLowerCase().includes(this.filter.toLocaleLowerCase())) : this.repos, !!this.language && "Todos" !== this.language && (this.reposShown = this.reposShown.filter(n => n.languages_array?.includes(this.language))), this.reposShown && 0 !== this.reposShown.length ? (this.reposEmpty = !1, this.error = null) : (this.reposEmpty = !0, this.error = { error: { message: "No repos found" }, status: null }) } sortReposByName() { this.repos.sort(this.sortingParameters.name.asc ? this.compareNameDesc : this.compareNameAsc), this.sortingParameters.lastSort = { column: "name", asc: this.sortingParameters.name.asc }, this.sortingParameters.name.asc = !this.sortingParameters.name.asc, this.sortingParameters.stars.asc = !1 } sortReposByStars() { this.repos.sort(this.sortingParameters.stars.asc ? this.compareStarsDesc : this.compareStarsAsc), this.sortingParameters.lastSort = { column: "stars", asc: this.sortingParameters.stars.asc }, this.sortingParameters.stars.asc = !this.sortingParameters.stars.asc, this.sortingParameters.name.asc = !1 } repeatLastSort() { "name" === this.sortingParameters.lastSort.column ? (this.sortingParameters.name.asc = this.sortingParameters.lastSort.asc, this.sortReposByName()) : (this.sortingParameters.stars.asc = this.sortingParameters.lastSort.asc, this.sortReposByStars()) } compareNameAsc(n, r) { return n.name.localeCompare(r.name) } compareNameDesc(n, r) { return -n.name.localeCompare(r.name) } compareStarsAsc(n, r) { return r.stargazers_count - n.stargazers_count } compareStarsDesc(n, r) { return n.stargazers_count - r.stargazers_count } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = on({ type: e, selectors: [["app-repos"]], inputs: { repos: "repos", filter: "filter", language: "language" }, features: [At], decls: 17, vars: 2, consts: [[1, "tableSection"], ["name", "name", 3, "click"], ["name", "description"], ["name", "url"], ["name", "stars", 3, "click"], ["src", "assets/star.svg", "alt", "ESTRELLAS"], ["name", "lenguajes"], [4, "ngIf", "ngIfElse"], ["reposNotFound", ""], [4, "ngFor", "ngForOf"], [1, "repo-url"], [1, "repo-url-link"], [3, "href"], [1, "center-text"], ["colspan", "5"], [1, "center-text", 3, "error"]], template: function (n, r) { if (1 & n && (j(0, "table", 0)(1, "thead")(2, "tr")(3, "th", 1), ge("click", function () { return r.sortReposByName() }), me(4, "NOMBRE"), H(), j(5, "th", 2), me(6, "DESCRIPCION"), H(), j(7, "th", 3), me(8, "URL"), H(), j(9, "th", 4), ge("click", function () { return r.sortReposByStars() }), Dt(10, "img", 5), H(), j(11, "th", 6), me(12, "LENGUAJES"), H()()(), j(13, "tbody"), We(14, qN, 2, 1, "ng-container", 7), We(15, KN, 2, 1, "ng-template", null, 8, Wi), H()()), 2 & n) { const o = _t(16); K(14), pe("ngIf", !r.reposEmpty)("ngIfElse", o) } }, dependencies: [El, bl, R_], styles: [".repo-url[_ngcontent-%COMP%]{width:20%}.repo-url-link[_ngcontent-%COMP%]{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;max-width:200px}table.tableSection[_ngcontent-%COMP%]{display:table;width:100%}table.tableSection[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%], table.tableSection[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]{width:100%}table.tableSection[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]{overflow-y:scroll;display:table;table-layout:fixed}table.tableSection[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]{overflow:auto;max-height:57vh;display:block}table.tableSection[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]{width:100%;display:table;table-layout:fixed}"] }), e })(), QN = (() => { class e { constructor() { } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = on({ type: e, selectors: [["app-loading"]], decls: 2, vars: 0, consts: [[1, "loading-message"]], template: function (n, r) { 1 & n && (j(0, "p", 0), me(1, "Cargando..."), H()) }, styles: [".loading-message[_ngcontent-%COMP%]{margin-top:20%;text-align:center}"] }), e })(); function JN(e, t) { if (1 & e) { const n = Vi(); j(0, "label")(1, "input", 16), ge("ngModelChange", function (o) { return Lr(n), Br(nt(3).filterLanguage = o) }), H(), me(2), H() } if (2 & e) { const n = t.$implicit, r = nt(3); K(1), lo("value", n), pe("ngModel", r.filterLanguage), K(1), fo("", n, " ") } } function YN(e, t) { if (1 & e) { const n = Vi(); Fn(0), j(1, "div", 7)(2, "div", 8)(3, "div", 9), Dt(4, "img", 10), H(), j(5, "h2"), me(6), H()(), j(7, "p"), me(8), H()(), j(9, "div", 11)(10, "input", 12), ge("ngModelChange", function (o) { return Lr(n), Br(nt(2).filterRepos = o) }), H(), j(11, "div", 13), We(12, JN, 3, 3, "label", 14), j(13, "label")(14, "input", 15), ge("ngModelChange", function (o) { return Lr(n), Br(nt(2).filterLanguage = o) }), H(), me(15, "Todos "), H()()(), Pn() } if (2 & e) { const n = nt(2), r = _t(1); K(4), lo("src", r.user.avatar_url, yi), K(2), Rt(r.user.login), K(2), Rt(r.user.bio), K(2), pe("ngModel", n.filterRepos)("disabled", 0 === r.repos.length), K(2), pe("ngForOf", r.allLanguages), K(2), pe("ngModel", n.filterLanguage) } } function XN(e, t) { 1 & e && (j(0, "span"), me(1, "Cargar m\xe1s"), H()) } function ex(e, t) { 1 & e && (j(0, "span"), me(1, "Cargando..."), H()) } function tx(e, t) { if (1 & e) { const n = Vi(); j(0, "button", 19), ge("click", function () { return Lr(n), nt(3), Br(_t(1).searchRepos()) }), We(1, XN, 2, 0, "span", 4), We(2, ex, 2, 0, "span", 4), H() } if (2 & e) { nt(3); const n = _t(1); pe("disabled", n.loadingRepos), K(1), pe("ngIf", !n.loadingRepos), K(1), pe("ngIf", n.loadingRepos) } } function nx(e, t) { if (1 & e && (Fn(0), Dt(1, "app-repos", 17), We(2, tx, 3, 3, "button", 18), Pn()), 2 & e) { const n = nt(2), r = _t(1); K(1), pe("repos", r.repos)("filter", n.filterRepos)("language", n.filterLanguage), K(1), pe("ngIf", r.reposRemaining || r.loadingRepos) } } function rx(e, t) { 1 & e && Dt(0, "app-loading") } function ox(e, t) { if (1 & e && (Fn(0), We(1, YN, 16, 7, "ng-container", 4), j(2, "div", 5), We(3, nx, 3, 4, "ng-container", 2), We(4, rx, 1, 0, "ng-template", null, 6, Wi), H(), Pn()), 2 & e) { const n = _t(5); nt(); const r = _t(1); K(1), pe("ngIf", !r.loadingUser), K(2), pe("ngIf", r.repos.length > 0 || !r.loadingRepos)("ngIfElse", n) } } function ix(e, t) { if (1 & e && (j(0, "div", 20), Dt(1, "app-not-found", 21), H()), 2 & e) { nt(); const n = _t(1); K(1), pe("error", n.errorUser) } } let sx = (() => { class e { constructor() { this.filterRepos = "", this.filterLanguage = "Todos" } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = on({ type: e, selectors: [["app-user-info"]], decls: 6, vars: 2, consts: [["result", ""], [1, "wrapper"], [4, "ngIf", "ngIfElse"], ["errorMessage", ""], [4, "ngIf"], [1, "repo-wrapper"], ["loadingMessage", ""], [1, "user-details"], [1, "basic-info"], [1, "avatar"], ["alt", "AVATAR", 3, "src"], [1, "repo-search"], ["type", "text", "placeholder", "Buscar repo del usuario", 3, "ngModel", "disabled", "ngModelChange"], [1, "languages-wrapper"], [4, "ngFor", "ngForOf"], ["type", "radio", "name", "filterLanguage", "value", "Todos", 3, "ngModel", "ngModelChange"], ["type", "radio", "name", "filterLanguage", 3, "value", "ngModel", "ngModelChange"], [3, "repos", "filter", "language"], [3, "disabled", "click", 4, "ngIf"], [3, "disabled", "click"], [1, "error-wrapper"], [3, "error"]], template: function (n, r) { if (1 & n && (Dt(0, "app-navbar", null, 0), j(2, "main", 1), We(3, ox, 6, 3, "ng-container", 2), H(), We(4, ix, 2, 1, "ng-template", null, 3, Wi)), 2 & n) { const o = _t(1), i = _t(5); K(3), pe("ngIf", o.found && !o.errorUser)("ngIfElse", i) } }, dependencies: [El, bl, To, oc, ql, Ss, GN, ZN, R_, QN], styles: [".wrapper[_ngcontent-%COMP%]{width:100%;max-width:1200px;display:grid;grid-template-columns:1fr 1fr;margin:0 auto;padding:10px 20px}.user-details[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:flex-start;margin-bottom:10px}.basic-info[_ngcontent-%COMP%]{display:flex;align-items:center}.avatar[_ngcontent-%COMP%]{width:20%;border-radius:50%;margin:0 20px}.avatar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;border-radius:50%}.repo-search[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:flex-end}.languages-wrapper[_ngcontent-%COMP%]{display:flex;justify-content:flex-end;max-width:900px;flex-wrap:wrap;gap:12px;margin:20px 0}.repo-wrapper[_ngcontent-%COMP%]{grid-column:1 / 3;display:flex;flex-direction:column;justify-content:center;max-width:1200px}.error-wrapper[_ngcontent-%COMP%]{width:100%;max-width:1200px;padding:40px;margin:0 auto;background-color:var(--third-color);grid-column:1/3;text-align:center}"] }), e })(), ax = (() => { class e { constructor() { this.title = "github-users" } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = on({ type: e, selectors: [["app-root"]], decls: 1, vars: 0, template: function (n, r) { 1 & n && Dt(0, "app-user-info") }, dependencies: [sx] }), e })(), ux = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = St({ type: e, bootstrap: [ax] }), e.\u0275inj = ct({ imports: [iT, HN, xT] }), e })(); (function OI() { Cm = !1 })(), oT().bootstrapModule(ux).catch(e => console.error(e)) } }, re => { re(re.s = 443) }]);
